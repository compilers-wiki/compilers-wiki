{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Compilers Wiki!","title":"Compilers Wiki"},{"location":"#welcome-to-the-compilers-wiki","text":"","title":"Welcome to the Compilers Wiki!"},{"location":"index.zh/","text":"\u6b22\u8fce\u8bbf\u95ee Compilers Wiki!","title":"Compilers Wiki"},{"location":"index.zh/#\u6b22\u8fce\u8bbf\u95ee-compilers-wiki","text":"","title":"\u6b22\u8fce\u8bbf\u95ee Compilers Wiki!"},{"location":"llvm/overview/","text":"Getting Started In this section, we will briefly describe the basics and concepts related to compilers and introduce the LLVM project. Note This section assumes that you do not have any background in compilers and that you already have an understanding of programming and can write simple C code. What is a compiler Conceptually, a compiler is a computer program that converts a programming language into another language. What we usually call a compiler generally converts a higher-level programming language such as C, C++, Fortran, etc. into a lower-level assembly language or machine code. Note that a compiler is not an editor, much less an IDE. LLVM Note Note that LLVM as discussed here refers to all the subprojects contained in the LLVM monorepo, not to the LLVM core in the traditional sense. LLVM is a set of reusable compiler toolchains. It currently contains at least the following subprojects. bolt A linked optimizer that optimizes the code layout of an application for improvements based on execution profiles collected by sampled profilers (such as the Linux perf tool). clang A GCC-compatible compiler front-end for the C family (C, C++, Objective C/C++, OpenCL, CUDA), known for its respectable compilation times and good diagnostic information. libcxx A new implementation of the C++ standard library, for C++11 and above. llvm The core of the LLVM project, including the LLVM intermediate language, various optimizations, and its corresponding command-line tools. mlir A general framework for writing various types of analysis and transformations in compilers and the intermediate representations they require. lld A high-performance, modular cross-platform linker. LLVM design philosophy LLVM is modular, and the most important aspect of LLVM is that it is designed as a set of libraries, not as a single command-line compiler like GCC or an opaque virtual machine like the JVM or .NET virtual machines. As an example, the LLVM optimizer provides a large number of passes that are compiled into one or more .o files and then built into a series of static or dynamic libraries. These libraries provide various parsing and transformation functions, and the passes are kept as independent as possible from each other, or if they depend on other parsing to do their job, their dependencies on other passes are explicitly declared. In contrast, during the actual optimization process of LLVM optimization, only the passes that are used are linked to the final application, not all of them. This straightforward design approach allows LLVM to provide a large number of features, some of which may be useful only to a specific audience, without affecting users of the library who just want to do other simple things. In contrast, traditional compiler optimizers are built as large amounts of interrelated code, making it difficult to split, reason about, and accelerate them. With LLVM, you can understand the individual optimizers without knowing how the whole system fits together. Pipeline of a compiler (taking Clang/LLVM as an example) Generally speaking, compilers are divided into front-end, middle-end and back-end. The front-end is responsible for analyzing and processing the source code and generating intermediate code. Lexing In this stage, the compiler divides the source code into tokens and ignores invalid information such as spaces and blank lines. Each token usually contains the following information. Type. Common types such as identifiers, keywords, separators, operators, literals, etc. Value. The value that this token actually corresponds to. Location in the source code. Recording the location of the token in the original code can help us generate better diagnostic information. As an example: 1 2 3 4 5 6 7 8 int foo ( int i ) { return i + 42 ; } int main () { int x = foo ( 24 ); return x - 24 ; } For the above code, Clang will generate the following token: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $ clang -c -Xclang -dump-tokens prog.c int 'int' [ StartOfLine ] Loc = <prog.c:1:1> identifier 'foo' [ LeadingSpace ] Loc = <prog.c:1:5> l_paren '(' Loc = <prog.c:1:8> int 'int' Loc = <prog.c:1:9> identifier 'i' [ LeadingSpace ] Loc = <prog.c:1:13> r_paren ')' Loc = <prog.c:1:14> l_brace '{' [ LeadingSpace ] Loc = <prog.c:1:16> return 'return' [ LeadingSpace ] Loc = <prog.c:1:18> identifier 'i' [ LeadingSpace ] Loc = <prog.c:1:25> plus '+' [ LeadingSpace ] Loc = <prog.c:1:27> numeric_constant '42' [ LeadingSpace ] Loc = <prog.c:1:29> semi ';' Loc = <prog.c:1:31> r_brace '}' [ LeadingSpace ] Loc = <prog.c:1:33> int 'int' [ StartOfLine ] Loc = <prog.c:3:1> identifier 'main' [ LeadingSpace ] Loc = <prog.c:3:5> l_paren '(' Loc = <prog.c:3:9> r_paren ')' Loc = <prog.c:3:10> l_brace '{' [ LeadingSpace ] Loc = <prog.c:3:12> int 'int' [ StartOfLine ] [ LeadingSpace ] Loc = <prog.c:4:3> identifier 'x' [ LeadingSpace ] Loc = <prog.c:4:7> equal '=' [ LeadingSpace ] Loc = <prog.c:4:9> identifier 'foo' [ LeadingSpace ] Loc = <prog.c:4:11> l_paren '(' Loc = <prog.c:4:14> numeric_constant '24' Loc = <prog.c:4:15> r_paren ')' Loc = <prog.c:4:17> semi ';' Loc = <prog.c:4:18> return 'return' [ StartOfLine ] [ LeadingSpace ] Loc = <prog.c:5:3> identifier 'x' [ LeadingSpace ] Loc = <prog.c:5:10> minus '-' [ LeadingSpace ] Loc = <prog.c:5:12> numeric_constant '24' [ LeadingSpace ] Loc = <prog.c:5:14> semi ';' Loc = <prog.c:5:16> r_brace '}' [ StartOfLine ] Loc = <prog.c:6:1> eof '' Loc = <prog.c:6:2> Parsing In this stage, the compiler converts the linear token stream into an Abstract Syntax Tree with specific syntax rules. The compiler also throws a diagnostic at this stage if there is an error in the syntax parsing. For the preceding code, the syntax tree generated by Clang can be viewed with the following command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ clang -Xclang -ast-dump -fsyntax-only prog.c TranslationUnitDecl 0x820688 <<invalid sloc>> <invalid sloc> | -FunctionDecl 0x877270 <prog.c:1:1, col:33> col:5 used foo 'int (int)' | | -ParmVarDecl 0x8771a0 <col:9, col:13> col:13 used i 'int' | ` -CompoundStmt 0x8773e8 <col:16, col:33> | ` -ReturnStmt 0x8773d8 <col:18, col:29> | ` -BinaryOperator 0x8773b8 <col:25, col:29> 'int' '+' | | -ImplicitCastExpr 0x8773a0 <col:25> 'int' <LValueToRValue> | | ` -DeclRefExpr 0x877360 <col:25> 'int' lvalue ParmVar 0x8771a0 'i' 'int' | ` -IntegerLiteral 0x877380 <col:29> 'int' 42 ` -FunctionDecl 0x877450 <line:3:1, line:6:1> line:3:5 main 'int ()' ` -CompoundStmt 0x8776b8 <col:12, line:6:1> | -DeclStmt 0x877618 <line:4:3, col:18> | ` -VarDecl 0x877508 <col:3, col:17> col:7 used x 'int' cinit | ` -CallExpr 0x8775f0 <col:11, col:17> 'int' | | -ImplicitCastExpr 0x8775d8 <col:11> 'int (*)(int)' <FunctionToPointerDecay> | | ` -DeclRefExpr 0x877570 <col:11> 'int (int)' Function 0x877270 'foo' 'int (int)' | ` -IntegerLiteral 0x877590 <col:15> 'int' 24 ` -ReturnStmt 0x8776a8 <line:5:3, col:14> ` -BinaryOperator 0x877688 <col:10, col:14> 'int' '-' | -ImplicitCastExpr 0x877670 <col:10> 'int' <LValueToRValue> | ` -DeclRefExpr 0x877630 <col:10> 'int' lvalue Var 0x877508 'x' 'int' ` -IntegerLiteral 0x877650 <col:14> 'int' 24 Intermediate code generation At this stage, the compiler converts the abstract syntax tree into an intermediate language. As in the example above, Clang generates the following intermediate language (LLVM IR). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ; ModuleID = 'prog.c' source_filename = \"prog.c\" target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\" target triple = \"x86_64-pc-linux-gnu\" ; Function Attrs: noinline nounwind optnone define dso_local i32 @foo ( i32 noundef %i ) #0 { entry: %i.addr = alloca i32 , align 4 store i32 %i , i32 * %i.addr , align 4 %0 = load i32 , i32 * %i.addr , align 4 %add = add nsw i32 %0 , 42 ret i32 %add } ; Function Attrs: noinline nounwind optnone define dso_local i32 @main () #0 { entry: %retval = alloca i32 , align 4 %x = alloca i32 , align 4 store i32 0 , i32 * %retval , align 4 %call = call i32 @foo ( i32 noundef 24 ) store i32 %call , i32 * %x , align 4 %0 = load i32 , i32 * %x , align 4 %sub = sub nsw i32 %0 , 24 ret i32 %sub } The middle-end is mainly responsible for analyzing and optimizing on the intermediate code to generate a more efficient intermediate code. In addition to the generic optimizations, the middle-end also contains those platform-specific optimizations. The specific responsibilities of the middle-end include: Analysis of the intermediate language, such as data flow analysis, alias analysis, etc. This phase is the basis for other optimizations performed by the compiler. Optimizing the intermediate language to convert its representation into a functionally equivalent but faster (or smaller) form. Common optimizations such as inline expansion, dead code elimination, constant propagation, loop conversion, etc. For example, we have this LLVM IR: 1 2 3 4 5 6 7 $ cat prog . ll define void @test ( ptr %Q , ptr %P ) { %DEAD = load i32 , ptr %Q store i32 %DEAD , ptr %P store i32 0 , ptr %P ret void } We can use the command line tools provided by LLVM to optimize it in any way we want. By working with the pipeline character on Unix systems, we can be very flexible in achieving various effects: 1 2 3 4 5 6 7 8 $ opt -passes = dse prog.ll | llvm-dis -f ; ModuleID = '<stdin>' source_filename = \"prog.ll\" define void @test ( ptr %Q, ptr %P ) { store i32 0 , ptr %P, align 4 ret void } Here we use the opt utility provided by LLVM to apply a dead code elimination optimization to prog.ll alone. Since opt generates human-unreadable LLVM bytecode, we then use llvm-dis to convert it to LLVM IR. The backend needs to generate the intermediate code into machine code for the corresponding platform, as well as some CPU architecture details for optimization. How to contribute to LLVM Submitting new bugs For a long time LLVM has been using Bugzilla as its bug tracker, but has now moved to Github issues . You can find some easy-to-follow bugs by looking at Good Frist Issue in issue. Submit a patch Note Note that LLVM is interested in dropping Phabricator and moving to Github Pull Requests, as detailed in 1 . Currently, the LLVM community still uses Phabricator to submit patches for code review. You can quickly sign up for a Phabricator account using a third-party account such as GitHub. You can submit your patches using the web page or Phabricator's own command line tool, arcanist. Specific documentation can be found here . The following is a simple example of using arcanist. Note Here we assume that you are using a Unix-like operating system and have Git installed and configured First we need to install arcanist: 1 git clone https://github.com/phacility/arcanist.git Next, add it to the environment variables: 1 export PATH = \" $PATH :/path/to/arcanist/bin/\" Authorize the login. 1 arc install-certificate When coding, we recommend using amend or manually rebase to compress our code into a commit for subsequent code review. Once our patch has been tested locally, it's ready to be sent out. But before doing so, we must be careful to ensure that our patch conforms to the LLVM Coding Style with clang-format. We recommend using the official git-clang-format tool provided by LLVM for best results and to avoid accidental changes to other code. You can add the path of git-clang-format to the PATH directly. 1 git clang-format HEAD~1 Note that the format doesn't commit automatically, so you need to. 1 git commit --amend -a After this is done, we can commit the patch to Phabricator using arc 1 arc diff arcanist will upload the latest commit to Phabricator, and when it succeeds, it will give us a link to our Revision. After the reviewer has looked at the code, he may give us some suggestions for changes, and we can continue to use arcanist to update our patches: 1 arc diff --update DXXXXX where DXXXXX is our previous Revision, which we have to specify manually because arcanist doesn't know the context. Communicating with the community Mailing list Although the community has phased out mailing lists, we still recommend that you subscribe to the list of commit records for the corresponding subprojects, which helps to keep you informed of what is happening in the project. For example, if you want to contribute to Clang, you can subscribe to the list cfe-commits , and if you want to contribute to the LLVM core, you can subscribe to the list llvm-commits . Discourse Discord Related links Getting Started with the LLVM System The Design Decisions of LLVM LLVM Language Reference Manual LLVM IR Tutorial - Phis, GEPs and other things, oh my! 2019 LLVM Developers\u2019 Meeting: E. Christopher & J. Doerfert \u201cIntroduction to LLVM\u201d \u201cClang\u201d CFE Internals Manual 2019 LLVM Developers\u2019 Meeting: S. Haastregt & A. Stulova \u201cAn overview of Clang \u201d P. Goldsborough \u201cclang-useful: Building useful tools with LLVM and clang for fun and profit\" You can refer to this post to know more. \u21a9","title":"llvm-overview"},{"location":"llvm/overview/#getting-started","text":"In this section, we will briefly describe the basics and concepts related to compilers and introduce the LLVM project. Note This section assumes that you do not have any background in compilers and that you already have an understanding of programming and can write simple C code.","title":"Getting Started"},{"location":"llvm/overview/#what-is-a-compiler","text":"Conceptually, a compiler is a computer program that converts a programming language into another language. What we usually call a compiler generally converts a higher-level programming language such as C, C++, Fortran, etc. into a lower-level assembly language or machine code. Note that a compiler is not an editor, much less an IDE.","title":"What is a compiler"},{"location":"llvm/overview/#llvm","text":"Note Note that LLVM as discussed here refers to all the subprojects contained in the LLVM monorepo, not to the LLVM core in the traditional sense. LLVM is a set of reusable compiler toolchains. It currently contains at least the following subprojects. bolt A linked optimizer that optimizes the code layout of an application for improvements based on execution profiles collected by sampled profilers (such as the Linux perf tool). clang A GCC-compatible compiler front-end for the C family (C, C++, Objective C/C++, OpenCL, CUDA), known for its respectable compilation times and good diagnostic information. libcxx A new implementation of the C++ standard library, for C++11 and above. llvm The core of the LLVM project, including the LLVM intermediate language, various optimizations, and its corresponding command-line tools. mlir A general framework for writing various types of analysis and transformations in compilers and the intermediate representations they require. lld A high-performance, modular cross-platform linker.","title":"LLVM"},{"location":"llvm/overview/#llvm-design-philosophy","text":"LLVM is modular, and the most important aspect of LLVM is that it is designed as a set of libraries, not as a single command-line compiler like GCC or an opaque virtual machine like the JVM or .NET virtual machines. As an example, the LLVM optimizer provides a large number of passes that are compiled into one or more .o files and then built into a series of static or dynamic libraries. These libraries provide various parsing and transformation functions, and the passes are kept as independent as possible from each other, or if they depend on other parsing to do their job, their dependencies on other passes are explicitly declared. In contrast, during the actual optimization process of LLVM optimization, only the passes that are used are linked to the final application, not all of them. This straightforward design approach allows LLVM to provide a large number of features, some of which may be useful only to a specific audience, without affecting users of the library who just want to do other simple things. In contrast, traditional compiler optimizers are built as large amounts of interrelated code, making it difficult to split, reason about, and accelerate them. With LLVM, you can understand the individual optimizers without knowing how the whole system fits together.","title":"LLVM design philosophy"},{"location":"llvm/overview/#pipeline-of-a-compiler-taking-clangllvm-as-an-example","text":"Generally speaking, compilers are divided into front-end, middle-end and back-end. The front-end is responsible for analyzing and processing the source code and generating intermediate code.","title":"Pipeline of a compiler (taking Clang/LLVM as an example)"},{"location":"llvm/overview/#lexing","text":"In this stage, the compiler divides the source code into tokens and ignores invalid information such as spaces and blank lines. Each token usually contains the following information. Type. Common types such as identifiers, keywords, separators, operators, literals, etc. Value. The value that this token actually corresponds to. Location in the source code. Recording the location of the token in the original code can help us generate better diagnostic information. As an example: 1 2 3 4 5 6 7 8 int foo ( int i ) { return i + 42 ; } int main () { int x = foo ( 24 ); return x - 24 ; } For the above code, Clang will generate the following token: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $ clang -c -Xclang -dump-tokens prog.c int 'int' [ StartOfLine ] Loc = <prog.c:1:1> identifier 'foo' [ LeadingSpace ] Loc = <prog.c:1:5> l_paren '(' Loc = <prog.c:1:8> int 'int' Loc = <prog.c:1:9> identifier 'i' [ LeadingSpace ] Loc = <prog.c:1:13> r_paren ')' Loc = <prog.c:1:14> l_brace '{' [ LeadingSpace ] Loc = <prog.c:1:16> return 'return' [ LeadingSpace ] Loc = <prog.c:1:18> identifier 'i' [ LeadingSpace ] Loc = <prog.c:1:25> plus '+' [ LeadingSpace ] Loc = <prog.c:1:27> numeric_constant '42' [ LeadingSpace ] Loc = <prog.c:1:29> semi ';' Loc = <prog.c:1:31> r_brace '}' [ LeadingSpace ] Loc = <prog.c:1:33> int 'int' [ StartOfLine ] Loc = <prog.c:3:1> identifier 'main' [ LeadingSpace ] Loc = <prog.c:3:5> l_paren '(' Loc = <prog.c:3:9> r_paren ')' Loc = <prog.c:3:10> l_brace '{' [ LeadingSpace ] Loc = <prog.c:3:12> int 'int' [ StartOfLine ] [ LeadingSpace ] Loc = <prog.c:4:3> identifier 'x' [ LeadingSpace ] Loc = <prog.c:4:7> equal '=' [ LeadingSpace ] Loc = <prog.c:4:9> identifier 'foo' [ LeadingSpace ] Loc = <prog.c:4:11> l_paren '(' Loc = <prog.c:4:14> numeric_constant '24' Loc = <prog.c:4:15> r_paren ')' Loc = <prog.c:4:17> semi ';' Loc = <prog.c:4:18> return 'return' [ StartOfLine ] [ LeadingSpace ] Loc = <prog.c:5:3> identifier 'x' [ LeadingSpace ] Loc = <prog.c:5:10> minus '-' [ LeadingSpace ] Loc = <prog.c:5:12> numeric_constant '24' [ LeadingSpace ] Loc = <prog.c:5:14> semi ';' Loc = <prog.c:5:16> r_brace '}' [ StartOfLine ] Loc = <prog.c:6:1> eof '' Loc = <prog.c:6:2>","title":"Lexing"},{"location":"llvm/overview/#parsing","text":"In this stage, the compiler converts the linear token stream into an Abstract Syntax Tree with specific syntax rules. The compiler also throws a diagnostic at this stage if there is an error in the syntax parsing. For the preceding code, the syntax tree generated by Clang can be viewed with the following command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ clang -Xclang -ast-dump -fsyntax-only prog.c TranslationUnitDecl 0x820688 <<invalid sloc>> <invalid sloc> | -FunctionDecl 0x877270 <prog.c:1:1, col:33> col:5 used foo 'int (int)' | | -ParmVarDecl 0x8771a0 <col:9, col:13> col:13 used i 'int' | ` -CompoundStmt 0x8773e8 <col:16, col:33> | ` -ReturnStmt 0x8773d8 <col:18, col:29> | ` -BinaryOperator 0x8773b8 <col:25, col:29> 'int' '+' | | -ImplicitCastExpr 0x8773a0 <col:25> 'int' <LValueToRValue> | | ` -DeclRefExpr 0x877360 <col:25> 'int' lvalue ParmVar 0x8771a0 'i' 'int' | ` -IntegerLiteral 0x877380 <col:29> 'int' 42 ` -FunctionDecl 0x877450 <line:3:1, line:6:1> line:3:5 main 'int ()' ` -CompoundStmt 0x8776b8 <col:12, line:6:1> | -DeclStmt 0x877618 <line:4:3, col:18> | ` -VarDecl 0x877508 <col:3, col:17> col:7 used x 'int' cinit | ` -CallExpr 0x8775f0 <col:11, col:17> 'int' | | -ImplicitCastExpr 0x8775d8 <col:11> 'int (*)(int)' <FunctionToPointerDecay> | | ` -DeclRefExpr 0x877570 <col:11> 'int (int)' Function 0x877270 'foo' 'int (int)' | ` -IntegerLiteral 0x877590 <col:15> 'int' 24 ` -ReturnStmt 0x8776a8 <line:5:3, col:14> ` -BinaryOperator 0x877688 <col:10, col:14> 'int' '-' | -ImplicitCastExpr 0x877670 <col:10> 'int' <LValueToRValue> | ` -DeclRefExpr 0x877630 <col:10> 'int' lvalue Var 0x877508 'x' 'int' ` -IntegerLiteral 0x877650 <col:14> 'int' 24","title":"Parsing"},{"location":"llvm/overview/#intermediate-code-generation","text":"At this stage, the compiler converts the abstract syntax tree into an intermediate language. As in the example above, Clang generates the following intermediate language (LLVM IR). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ; ModuleID = 'prog.c' source_filename = \"prog.c\" target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\" target triple = \"x86_64-pc-linux-gnu\" ; Function Attrs: noinline nounwind optnone define dso_local i32 @foo ( i32 noundef %i ) #0 { entry: %i.addr = alloca i32 , align 4 store i32 %i , i32 * %i.addr , align 4 %0 = load i32 , i32 * %i.addr , align 4 %add = add nsw i32 %0 , 42 ret i32 %add } ; Function Attrs: noinline nounwind optnone define dso_local i32 @main () #0 { entry: %retval = alloca i32 , align 4 %x = alloca i32 , align 4 store i32 0 , i32 * %retval , align 4 %call = call i32 @foo ( i32 noundef 24 ) store i32 %call , i32 * %x , align 4 %0 = load i32 , i32 * %x , align 4 %sub = sub nsw i32 %0 , 24 ret i32 %sub } The middle-end is mainly responsible for analyzing and optimizing on the intermediate code to generate a more efficient intermediate code. In addition to the generic optimizations, the middle-end also contains those platform-specific optimizations. The specific responsibilities of the middle-end include: Analysis of the intermediate language, such as data flow analysis, alias analysis, etc. This phase is the basis for other optimizations performed by the compiler. Optimizing the intermediate language to convert its representation into a functionally equivalent but faster (or smaller) form. Common optimizations such as inline expansion, dead code elimination, constant propagation, loop conversion, etc. For example, we have this LLVM IR: 1 2 3 4 5 6 7 $ cat prog . ll define void @test ( ptr %Q , ptr %P ) { %DEAD = load i32 , ptr %Q store i32 %DEAD , ptr %P store i32 0 , ptr %P ret void } We can use the command line tools provided by LLVM to optimize it in any way we want. By working with the pipeline character on Unix systems, we can be very flexible in achieving various effects: 1 2 3 4 5 6 7 8 $ opt -passes = dse prog.ll | llvm-dis -f ; ModuleID = '<stdin>' source_filename = \"prog.ll\" define void @test ( ptr %Q, ptr %P ) { store i32 0 , ptr %P, align 4 ret void } Here we use the opt utility provided by LLVM to apply a dead code elimination optimization to prog.ll alone. Since opt generates human-unreadable LLVM bytecode, we then use llvm-dis to convert it to LLVM IR. The backend needs to generate the intermediate code into machine code for the corresponding platform, as well as some CPU architecture details for optimization.","title":"Intermediate code generation"},{"location":"llvm/overview/#how-to-contribute-to-llvm","text":"","title":"How to contribute to LLVM"},{"location":"llvm/overview/#submitting-new-bugs","text":"For a long time LLVM has been using Bugzilla as its bug tracker, but has now moved to Github issues . You can find some easy-to-follow bugs by looking at Good Frist Issue in issue.","title":"Submitting new bugs"},{"location":"llvm/overview/#submit-a-patch","text":"Note Note that LLVM is interested in dropping Phabricator and moving to Github Pull Requests, as detailed in 1 . Currently, the LLVM community still uses Phabricator to submit patches for code review. You can quickly sign up for a Phabricator account using a third-party account such as GitHub. You can submit your patches using the web page or Phabricator's own command line tool, arcanist. Specific documentation can be found here . The following is a simple example of using arcanist. Note Here we assume that you are using a Unix-like operating system and have Git installed and configured First we need to install arcanist: 1 git clone https://github.com/phacility/arcanist.git Next, add it to the environment variables: 1 export PATH = \" $PATH :/path/to/arcanist/bin/\" Authorize the login. 1 arc install-certificate When coding, we recommend using amend or manually rebase to compress our code into a commit for subsequent code review. Once our patch has been tested locally, it's ready to be sent out. But before doing so, we must be careful to ensure that our patch conforms to the LLVM Coding Style with clang-format. We recommend using the official git-clang-format tool provided by LLVM for best results and to avoid accidental changes to other code. You can add the path of git-clang-format to the PATH directly. 1 git clang-format HEAD~1 Note that the format doesn't commit automatically, so you need to. 1 git commit --amend -a After this is done, we can commit the patch to Phabricator using arc 1 arc diff arcanist will upload the latest commit to Phabricator, and when it succeeds, it will give us a link to our Revision. After the reviewer has looked at the code, he may give us some suggestions for changes, and we can continue to use arcanist to update our patches: 1 arc diff --update DXXXXX where DXXXXX is our previous Revision, which we have to specify manually because arcanist doesn't know the context.","title":"Submit a patch"},{"location":"llvm/overview/#communicating-with-the-community","text":"Mailing list Although the community has phased out mailing lists, we still recommend that you subscribe to the list of commit records for the corresponding subprojects, which helps to keep you informed of what is happening in the project. For example, if you want to contribute to Clang, you can subscribe to the list cfe-commits , and if you want to contribute to the LLVM core, you can subscribe to the list llvm-commits . Discourse Discord","title":"Communicating with the community"},{"location":"llvm/overview/#related-links","text":"Getting Started with the LLVM System The Design Decisions of LLVM LLVM Language Reference Manual LLVM IR Tutorial - Phis, GEPs and other things, oh my! 2019 LLVM Developers\u2019 Meeting: E. Christopher & J. Doerfert \u201cIntroduction to LLVM\u201d \u201cClang\u201d CFE Internals Manual 2019 LLVM Developers\u2019 Meeting: S. Haastregt & A. Stulova \u201cAn overview of Clang \u201d P. Goldsborough \u201cclang-useful: Building useful tools with LLVM and clang for fun and profit\" You can refer to this post to know more. \u21a9","title":"Related links"},{"location":"llvm/overview/index.zh/","text":"\u65b0\u624b\u4e0a\u8def \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7b80\u8981\u53d9\u8ff0\u4e0e\u7f16\u8bd1\u5668\u6709\u5173\u7684\u76f8\u5173\u57fa\u672c\u77e5\u8bc6\u4e0e\u6982\u5ff5\uff0c\u5e76\u4ecb\u7ecd LLVM \u9879\u76ee\u3002 Note \u672c\u8282\u5047\u8bbe\u60a8\u6ca1\u6709\u4efb\u4f55\u4e0e\u7f16\u8bd1\u5668\u76f8\u5173\u7684\u80cc\u666f\u4e14\u5047\u8bbe\u60a8\u5df2\u5bf9\u7f16\u7a0b\u6709\u6240\u4e86\u89e3\uff0c\u53ef\u7f16\u5199\u7b80\u5355\u7684 C \u4ee3\u7801\u3002 \u4ec0\u4e48\u662f\u7f16\u8bd1\u5668 \u4ece\u6982\u5ff5\u4e0a\u8bb2\uff0c\u7f16\u8bd1\u5668\u662f\u4e00\u79cd\u5c06\u4e00\u79cd\u7f16\u7a0b\u8bed\u8a00\u8f6c\u6362\u4e3a\u53e6\u4e00\u79cd\u8bed\u8a00\u7684 \u8ba1\u7b97\u673a\u7a0b\u5e8f \u3002\u800c\u6211\u4eec\u901a\u5e38\u6240\u8bf4\u7684\u7f16\u8bd1\u5668\uff0c\u4e00\u822c\u4f1a\u5c06\u9ad8\u9636\u7f16\u7a0b\u8bed\u8a00\u5982 C, C++, Fortran \u7b49\u8f6c\u6362\u4e3a\u66f4\u5e95\u5c42\u7684\u6c47\u7f16\u8bed\u8a00\u6216\u8005\u673a\u5668\u4ee3\u7801\u3002 \u6ce8\u610f\u7f16\u8bd1\u5668\u4e0d\u662f\u7f16\u8f91\u5668\uff0c\u66f4\u4e0d\u662f IDE\u3002 LLVM Note \u6ce8\u610f\u8fd9\u91cc\u8ba8\u8bba\u7684 LLVM \u6307\u5305\u542b\u5728 LLVM monorepo \u4e2d\u7684\u6240\u6709\u5b50\u9879\u76ee\uff0c\u800c\u4e0d\u662f\u6307\u4f20\u7edf\u610f\u4e49\u4e0a\u7684 LLVM \u6838\u5fc3\u3002 LLVM \u662f\u4e00\u7ec4 \u53ef\u91cd\u7528\u7684 \u7f16\u8bd1\u5668\u5de5\u5177\u94fe\u3002\u76ee\u524d\u5b83\u81f3\u5c11\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u5b50\u9879\u76ee\uff1a bolt \u4e00\u4e2a\u94fe\u63a5\u540e\u7684\u4f18\u5316\u5668\uff0c\u901a\u8fc7\u57fa\u4e8e\u91c7\u6837\u5256\u6790\u5668\uff08\u5982Linux perf\u5de5\u5177\uff09\u6240\u6536\u96c6\u7684\u6267\u884c\u6982\u51b5\u6765\u4f18\u5316\u5e94\u7528\u7a0b\u5e8f\u7684\u4ee3\u7801\u5e03\u5c40\uff0c\u4ece\u800c\u5b9e\u73b0\u6539\u8fdb\u3002 clang \u4e00\u4e2a\u4e0e GCC \u517c\u5bb9\u7684 C \u5bb6\u65cf\uff08C, C++, Objective C/C++, OpenCL, CUDA\uff09\u7f16\u8bd1\u5668\u524d\u7aef\uff0c\u4ee5\u53ef\u89c2\u7684\u7f16\u8bd1\u65f6\u95f4\u4e0e\u826f\u597d\u7684\u8bca\u65ad\u4fe1\u606f\u800c\u8457\u540d\u3002 libcxx C++ \u6807\u51c6\u5e93\u7684\u4e00\u4e2a\u65b0\u5b9e\u73b0\uff0c\u9488\u5bf9 C++11 \u53ca\u4ee5\u4e0a\u7248\u672c\u3002 llvm LLVM \u9879\u76ee\u7684\u6838\u5fc3\uff0c\u5305\u62ec LLVM \u4e2d\u95f4\u8868\u793a\uff0c\u5404\u79cd\u4f18\u5316\u53ca\u5176\u5bf9\u5e94\u7684\u547d\u4ee4\u884c\u5de5\u5177\u3002 mlir \u4e00\u4e2a\u7528\u4e8e\u7f16\u5199\u7f16\u8bd1\u5668\u4e2d\u5404\u7c7b\u5206\u6790\u4e0e\u53d8\u6362\u53ca\u5176\u6240\u9700\u7684\u4e2d\u95f4\u8868\u793a\u7684\u901a\u7528\u6846\u67b6\u3002 lld \u4e00\u4e2a\u9ad8\u6027\u80fd\uff0c\u6a21\u5757\u5316\u7684\u8de8\u5e73\u53f0\u94fe\u63a5\u5668\u3002 LLVM \u7684\u8bbe\u8ba1\u7406\u5ff5 LLVM \u662f\u6a21\u5757\u5316\u7684\u3002 LLVM \u6700\u91cd\u8981\u7684\u65b9\u9762\u662f\u5b83\u88ab\u8bbe\u8ba1\u4e3a\u4e00\u7ec4\u5e93\uff0c\u800c\u4e0d\u662f\u50cf GCC \u90a3\u6837\u7684\u5355\u4e00\u547d\u4ee4\u884c\u7f16\u8bd1\u5668\u6216\u50cf JVM \u6216 .NET \u865a\u62df\u673a\u90a3\u6837\u7684\u4e0d\u900f\u660e\u865a\u62df\u673a\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c LLVM \u4f18\u5316\u5668\u63d0\u4f9b\u4e86\u5927\u91cf pass \uff0c\u5b83\u4eec\u88ab\u7f16\u8bd1\u6210\u4e00\u4e2a\u6216\u591a\u4e2a .o \u6587\u4ef6\uff0c\u7136\u540e\u88ab\u6784\u5efa\u6210\u4e00\u7cfb\u5217\u9759\u6001\u6216\u52a8\u6001\u5e93\u3002\u8fd9\u4e9b\u5e93\u63d0\u4f9b\u5404\u79cd\u5206\u6790\u548c\u8f6c\u6362\u529f\u80fd\uff0c\u5e76\u4e14 pass \u4e4b\u95f4\u5c3d\u53ef\u80fd\u4fdd\u6301\u72ec\u7acb\uff0c\u6216\u8005\u5982\u679c\u5b83\u4eec\u4f9d\u8d56\u4e8e\u5176\u4ed6\u5206\u6790\u6765\u5b8c\u6210\u5176\u5de5\u4f5c\uff0c\u5219\u660e\u786e\u58f0\u660e\u5b83\u4eec\u4e0e\u5176\u4ed6 pass \u4e4b\u95f4\u7684\u4f9d\u8d56\u5173\u7cfb\u3002\u800c\u5728 LLVM \u4f18\u5316\u5b9e\u9645\u7684\u4f18\u5316\u8fc7\u7a0b\u4e2d\uff0c\u53ea\u6709\u88ab\u4f7f\u7528\u7684 pass \u4f1a\u88ab\u94fe\u63a5\u5230\u6700\u7ec8\u5e94\u7528\u7a0b\u5e8f\uff0c\u800c\u4e0d\u662f\u6240\u6709\u7684\u3002 \u8fd9\u79cd\u76f4\u63a5\u7684\u8bbe\u8ba1\u65b9\u6cd5\u5141\u8bb8 LLVM \u63d0\u4f9b\u5927\u91cf\u7684\u529f\u80fd\uff0c\u5176\u4e2d\u4e00\u4e9b\u53ef\u80fd\u53ea\u5bf9\u7279\u5b9a\u7684\u53d7\u4f17\u6709\u7528\uff0c\u800c\u4e0d\u4f1a\u5f71\u54cd\u5230\u53ea\u60f3\u505a\u5176\u4ed6\u7b80\u5355\u4e8b\u60c5\u7684\u5e93\u7684\u7528\u6237\u3002\u76f8\u6bd4\u4e4b\u4e0b\uff0c\u4f20\u7edf\u7684\u7f16\u8bd1\u5668\u4f18\u5316\u5668\u662f\u4f5c\u4e3a\u5927\u91cf\u76f8\u4e92\u5173\u8054\u7684\u4ee3\u7801\u6784\u5efa\u7684\uff0c\u5f88\u96be\u5bf9\u5176\u8fdb\u884c\u5b50\u96c6\u5316\u3001\u63a8\u7406\u548c\u52a0\u901f\u3002\u4f7f\u7528 LLVM\uff0c\u60a8\u53ef\u4ee5\u5728\u4e0d\u77e5\u9053\u6574\u4e2a\u7cfb\u7edf\u5982\u4f55\u7ec4\u5408\u5728\u4e00\u8d77\u7684\u60c5\u51b5\u4e0b\u4e86\u89e3\u5404\u4e2a\u4f18\u5316\u5668\u3002 \u7f16\u8bd1\u5668\u7684\u6d41\u7a0b\uff08\u4ee5 Clang/LLVM \u4e3a\u4f8b\uff09 \u901a\u5e38\u6765\u8bf4\uff0c\u7f16\u8bd1\u5668\u5206\u4e3a\u524d\u7aef\uff0c\u4e2d\u7aef\u4e0e\u540e\u7aef\u3002 \u524d\u7aef\u7684\u804c\u8d23\u4e3b\u8981\u5728\u4e8e\u5bf9\u6e90\u4ee3\u7801\u8fdb\u884c\u5206\u6790\u548c\u5904\u7406\u5e76\u751f\u6210\u4e2d\u95f4\u4ee3\u7801\u3002 \u8bcd\u6cd5\u5206\u6790 \u5728\u8fd9\u4e2a\u9636\u6bb5\uff0c\u7f16\u8bd1\u5668\u4f1a\u5c06\u6e90\u4ee3\u7801\u5206\u6210\u4e00\u4e2a\u4e2a\u7684 token\uff0c\u5e76\u5ffd\u7565\u6389\u8bf8\u5982\u7a7a\u683c\u7a7a\u884c\u7b49\u65e0\u6548\u4fe1\u606f\u3002\u6bcf\u4e2a token \u901a\u5e38\u5305\u542b\u4ee5\u4e0b\u4fe1\u606f\uff1a \u7c7b\u578b\u3002\u5e38\u89c1\u7684\u7c7b\u578b\u5982\u6807\u8bc6\u7b26\u3001\u5173\u952e\u8bcd\u3001\u5206\u9694\u7b26\u3001\u8fd0\u7b97\u7b26\u3001\u5b57\u9762\u91cf\u7b49\u3002 \u503c\u3002\u6b64 token \u5b9e\u9645\u5bf9\u5e94\u7684\u503c\u3002 \u6e90\u4ee3\u7801\u4e2d\u7684\u4f4d\u7f6e\u3002\u8bb0\u5f55 token \u5728\u539f\u59cb\u4ee3\u7801\u4e2d\u7684\u4f4d\u7f6e\u53ef\u5e2e\u52a9\u6211\u4eec\u751f\u6210\u66f4\u597d\u7684\u8bca\u65ad\u4fe1\u606f\u3002 \u4e3e\u4e2a\u4f8b\u5b50: 1 2 3 4 5 6 7 8 int foo ( int i ) { return i + 42 ; } int main () { int x = foo ( 24 ); return x - 24 ; } \u5bf9\u4e8e\u4ee5\u4e0a\u4ee3\u7801\uff0cClang \u4f1a\u751f\u6210\u5982\u4e0b token: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $ clang -c -Xclang -dump-tokens prog.c int 'int' [ StartOfLine ] Loc = <prog.c:1:1> identifier 'foo' [ LeadingSpace ] Loc = <prog.c:1:5> l_paren '(' Loc = <prog.c:1:8> int 'int' Loc = <prog.c:1:9> identifier 'i' [ LeadingSpace ] Loc = <prog.c:1:13> r_paren ')' Loc = <prog.c:1:14> l_brace '{' [ LeadingSpace ] Loc = <prog.c:1:16> return 'return' [ LeadingSpace ] Loc = <prog.c:1:18> identifier 'i' [ LeadingSpace ] Loc = <prog.c:1:25> plus '+' [ LeadingSpace ] Loc = <prog.c:1:27> numeric_constant '42' [ LeadingSpace ] Loc = <prog.c:1:29> semi ';' Loc = <prog.c:1:31> r_brace '}' [ LeadingSpace ] Loc = <prog.c:1:33> int 'int' [ StartOfLine ] Loc = <prog.c:3:1> identifier 'main' [ LeadingSpace ] Loc = <prog.c:3:5> l_paren '(' Loc = <prog.c:3:9> r_paren ')' Loc = <prog.c:3:10> l_brace '{' [ LeadingSpace ] Loc = <prog.c:3:12> int 'int' [ StartOfLine ] [ LeadingSpace ] Loc = <prog.c:4:3> identifier 'x' [ LeadingSpace ] Loc = <prog.c:4:7> equal '=' [ LeadingSpace ] Loc = <prog.c:4:9> identifier 'foo' [ LeadingSpace ] Loc = <prog.c:4:11> l_paren '(' Loc = <prog.c:4:14> numeric_constant '24' Loc = <prog.c:4:15> r_paren ')' Loc = <prog.c:4:17> semi ';' Loc = <prog.c:4:18> return 'return' [ StartOfLine ] [ LeadingSpace ] Loc = <prog.c:5:3> identifier 'x' [ LeadingSpace ] Loc = <prog.c:5:10> minus '-' [ LeadingSpace ] Loc = <prog.c:5:12> numeric_constant '24' [ LeadingSpace ] Loc = <prog.c:5:14> semi ';' Loc = <prog.c:5:16> r_brace '}' [ StartOfLine ] Loc = <prog.c:6:1> eof '' Loc = <prog.c:6:2> \u8bed\u6cd5\u5206\u6790 \u5728\u8fd9\u4e2a\u9636\u6bb5\uff0c\u7f16\u8bd1\u5668\u4f1a\u5c06\u7ebf\u6027\u7684 token \u6d41\u8f6c\u6362\u4e3a\u5177\u6709\u7279\u5b9a\u8bed\u6cd5\u89c4\u5219\u7684\u62bd\u8c61\u8bed\u6cd5\u6811\uff08Abstract Syntax Tree\uff09\u3002\u5982\u679c\u5728\u8bed\u6cd5\u89e3\u6790\u4e2d\u51fa\u73b0\u9519\u8bef\uff0c\u7f16\u8bd1\u5668\u4e5f\u4f1a\u5728\u8fd9\u4e2a\u9636\u6bb5\u629b\u51fa\u4e00\u4e2a\u8bca\u65ad\u3002 \u5bf9\u4e8e\u524d\u9762\u7684\u4ee3\u7801\uff0c\u53ef\u4ee5\u7528\u4ee5\u4e0b\u547d\u4ee4\u67e5\u770b Clang \u6240\u751f\u6210\u7684\u8bed\u6cd5\u6811\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ clang -Xclang -ast-dump -fsyntax-only prog.c TranslationUnitDecl 0x820688 <<invalid sloc>> <invalid sloc> | -FunctionDecl 0x877270 <prog.c:1:1, col:33> col:5 used foo 'int (int)' | | -ParmVarDecl 0x8771a0 <col:9, col:13> col:13 used i 'int' | ` -CompoundStmt 0x8773e8 <col:16, col:33> | ` -ReturnStmt 0x8773d8 <col:18, col:29> | ` -BinaryOperator 0x8773b8 <col:25, col:29> 'int' '+' | | -ImplicitCastExpr 0x8773a0 <col:25> 'int' <LValueToRValue> | | ` -DeclRefExpr 0x877360 <col:25> 'int' lvalue ParmVar 0x8771a0 'i' 'int' | ` -IntegerLiteral 0x877380 <col:29> 'int' 42 ` -FunctionDecl 0x877450 <line:3:1, line:6:1> line:3:5 main 'int ()' ` -CompoundStmt 0x8776b8 <col:12, line:6:1> | -DeclStmt 0x877618 <line:4:3, col:18> | ` -VarDecl 0x877508 <col:3, col:17> col:7 used x 'int' cinit | ` -CallExpr 0x8775f0 <col:11, col:17> 'int' | | -ImplicitCastExpr 0x8775d8 <col:11> 'int (*)(int)' <FunctionToPointerDecay> | | ` -DeclRefExpr 0x877570 <col:11> 'int (int)' Function 0x877270 'foo' 'int (int)' | ` -IntegerLiteral 0x877590 <col:15> 'int' 24 ` -ReturnStmt 0x8776a8 <line:5:3, col:14> ` -BinaryOperator 0x877688 <col:10, col:14> 'int' '-' | -ImplicitCastExpr 0x877670 <col:10> 'int' <LValueToRValue> | ` -DeclRefExpr 0x877630 <col:10> 'int' lvalue Var 0x877508 'x' 'int' ` -IntegerLiteral 0x877650 <col:14> 'int' 24 \u4e2d\u95f4\u4ee3\u7801\u751f\u6210 \u5728\u8fd9\u4e2a\u9636\u6bb5\uff0c\u7f16\u8bd1\u5668\u4f1a\u5c06\u62bd\u8c61\u8bed\u6cd5\u6811\u8f6c\u6362\u4e3a\u4e2d\u95f4\u8868\u793a\u3002 \u8fd8\u662f\u4e0a\u9762\u7684\u4f8b\u5b50\uff0cClang \u4f1a\u751f\u6210\u4ee5\u4e0b\u4e2d\u95f4\u8868\u793a\uff08LLVM IR\uff09\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ; ModuleID = 'prog.c' source_filename = \"prog.c\" target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\" target triple = \"x86_64-pc-linux-gnu\" ; Function Attrs: noinline nounwind optnone define dso_local i32 @foo ( i32 noundef %i ) #0 { entry: %i.addr = alloca i32 , align 4 store i32 %i , i32 * %i.addr , align 4 %0 = load i32 , i32 * %i.addr , align 4 %add = add nsw i32 %0 , 42 ret i32 %add } ; Function Attrs: noinline nounwind optnone define dso_local i32 @main () #0 { entry: %retval = alloca i32 , align 4 %x = alloca i32 , align 4 store i32 0 , i32 * %retval , align 4 %call = call i32 @foo ( i32 noundef 24 ) store i32 %call , i32 * %x , align 4 %0 = load i32 , i32 * %x , align 4 %sub = sub nsw i32 %0 , 24 ret i32 %sub } \u4e2d\u7aef\u4e3b\u8981\u8d1f\u8d23\u5728\u4e2d\u95f4\u4ee3\u7801\u4e0a\u8fdb\u884c\u5206\u6790\u548c\u4f18\u5316\uff0c\u751f\u6210\u66f4\u9ad8\u6548\u7684\u4e2d\u95f4\u4ee3\u7801\u3002\u9664\u4e86\u901a\u7528\u7684\u4f18\u5316\uff0c\u4e2d\u7aef\u4e5f\u5305\u542b\u4e86\u90a3\u4e9b\u5e73\u53f0\u76f8\u5173\u7684\u7279\u6b8a\u4f18\u5316\u3002 \u4e2d\u7aef\u7684\u5177\u4f53\u804c\u8d23\u5305\u542b\uff1a \u5bf9\u4e2d\u95f4\u8868\u793a\u8fdb\u884c\u5206\u6790\uff0c\u5982\u6570\u636e\u6d41\u5206\u6790\uff0c\u522b\u540d\u5206\u6790\u7b49\u3002\u6b64\u9636\u6bb5\u662f\u7f16\u8bd1\u5668\u8fdb\u884c\u5176\u4ed6\u4f18\u5316\u7684\u57fa\u7840\u3002 \u4f18\u5316\u4e2d\u95f4\u8868\u793a\uff0c\u5c06\u5176\u8868\u8ff0\u88ab\u8f6c\u5316\u4e3a\u529f\u80fd\u7b49\u540c\u4f46\u66f4\u5feb\uff08\u6216\u66f4\u5c0f\uff09\u7684\u5f62\u5f0f\u3002\u5e38\u89c1\u7684\u4f18\u5316\u5982\u5185\u8054\u5c55\u5f00\uff0c\u6b7b\u4ee3\u7801\u6d88\u9664\uff0c\u5e38\u91cf\u4f20\u64ad\u3001\u5faa\u73af\u8f6c\u6362\u7b49\u3002 \u4f8b\u5982\u6211\u4eec\u6709\u8fd9\u4e48\u4e00\u6bb5 LLVM IR: 1 2 3 4 5 6 7 $ cat prog . ll define void @test ( ptr %Q , ptr %P ) { %DEAD = load i32 , ptr %Q store i32 %DEAD , ptr %P store i32 0 , ptr %P ret void } \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 LLVM \u63d0\u4f9b\u7684\u547d\u4ee4\u884c\u5de5\u5177\u5bf9\u5176\u8fdb\u884c\u4e00\u6bb5\u4efb\u610f\u7684\u4f18\u5316\u3002\u901a\u8fc7\u914d\u5408 Unix \u7cfb\u7edf\u4e0a\u7684\u7ba1\u9053\u7b26\uff0c\u6211\u4eec\u53ef\u4ee5\u975e\u5e38\u7075\u6d3b\u5730\u8fbe\u5230\u5404\u79cd\u6548\u679c\uff1a 1 2 3 4 5 6 7 8 $ opt -passes = dse prog.ll | llvm-dis -f ; ModuleID = '<stdin>' source_filename = \"prog.ll\" define void @test ( ptr %Q, ptr %P ) { store i32 0 , ptr %P, align 4 ret void } \u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u4e86 LLVM \u63d0\u4f9b\u7684 opt \u5de5\u5177\u5355\u72ec\u5bf9 prog.ll \u4f7f\u7528\u4e86\u6b7b\u4ee3\u7801\u6d88\u9664\u7684\u4f18\u5316\u3002\u7531\u4e8e opt \u4f1a\u751f\u6210\u4eba\u7c7b\u4e0d\u53ef\u9605\u8bfb\u7684 LLVM \u5b57\u8282\u7801\uff0c\u6211\u4eec\u63a5\u7740\u53c8\u4f7f\u7528\u4e86 llvm-dis \u5c06\u5176\u8f6c\u6362\u4e3a LLVM IR\u3002 \u540e\u7aef\u9700\u8981\u5c06\u4e2d\u95f4\u4ee3\u7801\u751f\u6210\u5bf9\u5e94\u5e73\u53f0\u7684\u673a\u5668\u4ee3\u7801\uff0c\u4ee5\u53ca\u8fdb\u884c\u4e00\u4e9b\u4f53\u7cfb\u67b6\u6784\u7684\u7ec6\u8282\u7684\u4f18\u5316\u3002 \u5982\u4f55\u7ed9 LLVM \u505a\u8d21\u732e \u63d0\u4ea4\u65b0 Bug \u5728\u8fc7\u53bb\u7684\u5f88\u957f\u4e00\u6bb5\u65f6\u95f4\u91cc\uff0cLLVM \u4e00\u76f4\u4f7f\u7528 Bugzilla \u4f5c\u4e3a\u5176 Bug tracker\uff0c\u4f46\u662f\u73b0\u5728\u5df2\u8f6c\u5411 Github issues \u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u67e5\u770b issue \u4e2d\u7684 Good Frist Issue \u6765\u5bfb\u627e\u4e00\u4e9b\u5bb9\u6613\u4e0a\u624b\u7684 Bug\u3002 \u63d0\u4ea4\u8865\u4e01 Note \u6ce8\u610f\uff0cLLVM \u6709\u610f\u5411\u653e\u5f03 Phabricator \u5e76\u8f6c\u5411 Github Pull Requests\uff0c\u8be6\u89c1 [^Code Review Process Update]\u3002 \u76ee\u524d\uff0cLLVM \u8fd8\u4e3b\u8981\u4f7f\u7528 Phabricator \u6765\u63d0\u4ea4\u8865\u4e01\u8fdb\u884c\u4ee3\u7801\u5ba1\u67e5\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 Github \u7b49\u7b2c\u4e09\u65b9\u8d26\u53f7\u5feb\u901f\u6ce8\u518c\u4e00\u4e2a Phabricator \u8d26\u53f7\u3002 \u60a8\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u7f51\u9875\u6216 Phabricator \u81ea\u5e26\u7684\u547d\u4ee4\u884c\u5de5\u5177 arcanist \u6765\u63d0\u4ea4\u60a8\u7684\u8865\u4e01\u3002\u5177\u4f53\u6587\u6863\u53ef\u53c2\u8003 \u8fd9\u91cc \u3002\u4e0b\u9762\u662f\u4f7f\u7528 arcanist \u7684\u7b80\u5355\u793a\u4f8b\uff1a Note \u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u60a8\u4f7f\u7528\u7684\u662f Unix-like \u7684\u64cd\u4f5c\u7cfb\u7edf\u5e76\u5df2\u5b89\u88c5\u5e76\u914d\u7f6e\u597d\u4e86 Git \u9996\u5148\u6211\u4eec\u9700\u8981\u5b89\u88c5 arcanist\uff1a 1 git clone https://github.com/phacility/arcanist.git \u63a5\u7740\u5c06\u5176\u6dfb\u52a0\u5230\u73af\u5883\u53d8\u91cf\u4e2d\uff1a 1 export PATH = \" $PATH :/path/to/arcanist/bin/\" \u6388\u6743\u767b\u9646\uff1a 1 arc install-certificate \u5728\u8fdb\u884c\u7f16\u7801\u65f6\uff0c\u6211\u4eec\u63a8\u8350\u4f7f\u7528 amend \u6216\u624b\u52a8 rebase \u5c06\u6211\u4eec\u7684\u4ee3\u7801\u538b\u7f29\u6210\u4e00\u4e2a commit \uff0c\u65b9\u4fbf\u540e\u7eed\u7684\u4ee3\u7801\u5ba1\u67e5\u3002 \u5f53\u6211\u4eec\u7684 patch \u5728\u672c\u5730\u901a\u8fc7\u6d4b\u8bd5\u540e\uff0c\u4fbf\u53ef\u4ee5\u51c6\u5907\u53d1\u51fa\u53bb\u4e86\u3002\u4f46\u5728\u6b64\u4e4b\u524d\u4e00\u5b9a\u8981\u6ce8\u610f\u7528 clang-format \u4fdd\u8bc1\u6211\u4eec\u7684 patch \u7b26\u5408 LLVM Coding Style\u3002 \u5efa\u8bae\u4f7f\u7528 LLVM \u5b98\u65b9\u63d0\u4f9b\u7684 git-clang-format \u5de5\u5177\uff0c\u6548\u679c\u6700\u597d\uff0c\u907f\u514d\u610f\u5916\u4fee\u6539\u5230\u5176\u4ed6\u7684\u4ee3\u7801\u3002 \u53ef\u4ee5\u76f4\u63a5\u5c06 git-clang-format \u6240\u5728\u7684\u8def\u5f84\u6dfb\u52a0\u5230 PATH \u4e2d\u5c31\u53ef\u4ee5\u4e86\u3002 1 git clang-format HEAD~1 \u6ce8\u610fformat\u540e\u5e76\u4e0d\u4f1a\u81ea\u52a8\u63d0\u4ea4\uff0c\u6240\u4ee5\u60a8\u9700\u8981\uff1a 1 git commit --amend -a \u5728\u4e0a\u8ff0\u5de5\u4f5c\u5b8c\u6210\u540e\uff0c\u6211\u4eec\u4fbf\u53ef\u4ee5\u4f7f\u7528 arc \u63d0\u4ea4\u8865\u4e01\u5230 Phabricator \u4e86\uff1a 1 arc diff arcanist \u4f1a\u5c06\u6700\u8fd1\u7684\u4e00\u4e2a\u63d0\u4ea4\u4e0a\u4f20\u5230 Phabricator \u4e0a\uff0c\u6210\u529f\u540e\u5b83\u4f1a\u7ed9\u6211\u4eec\u4e00\u4e2a\u94fe\u63a5\uff0c\u8fd9\u4fbf\u662f\u6211\u4eec\u7684 Revision \u5566\u3002 \u5728 reviewer \u770b\u8fc7\u4ee3\u7801\u540e\uff0c\u53ef\u80fd\u4f1a\u7ed9\u6211\u4eec\u4e00\u4e9b\u4fee\u6539\u7684\u5efa\u8bae\uff0c\u6211\u4eec\u53ef\u4ee5\u7ee7\u7eed\u4f7f\u7528 arcanist \u66f4\u65b0\u6211\u4eec\u7684\u8865\u4e01: 1 arc diff --update DXXXXX \u5176\u4e2d DXXXXX \u662f\u6211\u4eec\u4e4b\u524d\u7684 Revision\uff0c\u56e0\u4e3a arcanist \u65e0\u6cd5\u77e5\u9053\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u624b\u52a8\u6307\u5b9a\u3002 \u4e0e\u793e\u533a\u6c9f\u901a \u90ae\u4ef6\u5217\u8868 \u5c3d\u7ba1\u793e\u533a\u5df2\u9010\u6b65\u6dd8\u6c70\u4e86\u90ae\u4ef6\u5217\u8868\uff0c\u6211\u4eec\u4ecd\u5efa\u8bae\u60a8\u8ba2\u9605\u5bf9\u5e94\u5b50\u9879\u76ee\u7684\u63d0\u4ea4\u8bb0\u5f55\u5217\u8868\uff0c\u8fd9\u6709\u52a9\u4e8e\u5e2e\u52a9\u60a8\u4e86\u89e3\u9879\u76ee\u4e2d\u6b63\u5728\u53d1\u751f\u7684\u4e8b\u60c5\u3002\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5982\u679c\u60a8\u60f3\u5411 Clang \u505a\u8d21\u732e\uff0c\u60a8\u53ef\u4ee5\u8ba2\u9605 cfe-commits \u8fd9\u4e2a\u5217\u8868\uff0c\u5982\u679c\u60a8\u60f3\u5411 LLVM \u6838\u5fc3\u505a\u8d21\u732e\uff0c\u53ef\u8ba2\u9605 llvm-commits \u8fd9\u4e2a\u5217\u8868\u3002 Discourse Discord \u76f8\u5173\u94fe\u63a5 Getting Started with the LLVM System The Design Decisions of LLVM LLVM Language Reference Manual LLVM IR Tutorial - Phis, GEPs and other things, oh my! 2019 LLVM Developers\u2019 Meeting: E. Christopher & J. Doerfert \u201cIntroduction to LLVM\u201d \u201cClang\u201d CFE Internals Manual 2019 LLVM Developers\u2019 Meeting: S. Haastregt & A. Stulova \u201cAn overview of Clang \u201d P. Goldsborough \u201cclang-useful: Building useful tools with LLVM and clang for fun and profit\" \u60a8\u53ef\u4ee5\u53c2\u8003 \u672c\u5e16 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002 \u21a9","title":"llvm-overview"},{"location":"llvm/overview/index.zh/#\u65b0\u624b\u4e0a\u8def","text":"\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u7b80\u8981\u53d9\u8ff0\u4e0e\u7f16\u8bd1\u5668\u6709\u5173\u7684\u76f8\u5173\u57fa\u672c\u77e5\u8bc6\u4e0e\u6982\u5ff5\uff0c\u5e76\u4ecb\u7ecd LLVM \u9879\u76ee\u3002 Note \u672c\u8282\u5047\u8bbe\u60a8\u6ca1\u6709\u4efb\u4f55\u4e0e\u7f16\u8bd1\u5668\u76f8\u5173\u7684\u80cc\u666f\u4e14\u5047\u8bbe\u60a8\u5df2\u5bf9\u7f16\u7a0b\u6709\u6240\u4e86\u89e3\uff0c\u53ef\u7f16\u5199\u7b80\u5355\u7684 C \u4ee3\u7801\u3002","title":"\u65b0\u624b\u4e0a\u8def"},{"location":"llvm/overview/index.zh/#\u4ec0\u4e48\u662f\u7f16\u8bd1\u5668","text":"\u4ece\u6982\u5ff5\u4e0a\u8bb2\uff0c\u7f16\u8bd1\u5668\u662f\u4e00\u79cd\u5c06\u4e00\u79cd\u7f16\u7a0b\u8bed\u8a00\u8f6c\u6362\u4e3a\u53e6\u4e00\u79cd\u8bed\u8a00\u7684 \u8ba1\u7b97\u673a\u7a0b\u5e8f \u3002\u800c\u6211\u4eec\u901a\u5e38\u6240\u8bf4\u7684\u7f16\u8bd1\u5668\uff0c\u4e00\u822c\u4f1a\u5c06\u9ad8\u9636\u7f16\u7a0b\u8bed\u8a00\u5982 C, C++, Fortran \u7b49\u8f6c\u6362\u4e3a\u66f4\u5e95\u5c42\u7684\u6c47\u7f16\u8bed\u8a00\u6216\u8005\u673a\u5668\u4ee3\u7801\u3002 \u6ce8\u610f\u7f16\u8bd1\u5668\u4e0d\u662f\u7f16\u8f91\u5668\uff0c\u66f4\u4e0d\u662f IDE\u3002","title":"\u4ec0\u4e48\u662f\u7f16\u8bd1\u5668"},{"location":"llvm/overview/index.zh/#llvm","text":"Note \u6ce8\u610f\u8fd9\u91cc\u8ba8\u8bba\u7684 LLVM \u6307\u5305\u542b\u5728 LLVM monorepo \u4e2d\u7684\u6240\u6709\u5b50\u9879\u76ee\uff0c\u800c\u4e0d\u662f\u6307\u4f20\u7edf\u610f\u4e49\u4e0a\u7684 LLVM \u6838\u5fc3\u3002 LLVM \u662f\u4e00\u7ec4 \u53ef\u91cd\u7528\u7684 \u7f16\u8bd1\u5668\u5de5\u5177\u94fe\u3002\u76ee\u524d\u5b83\u81f3\u5c11\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u5b50\u9879\u76ee\uff1a bolt \u4e00\u4e2a\u94fe\u63a5\u540e\u7684\u4f18\u5316\u5668\uff0c\u901a\u8fc7\u57fa\u4e8e\u91c7\u6837\u5256\u6790\u5668\uff08\u5982Linux perf\u5de5\u5177\uff09\u6240\u6536\u96c6\u7684\u6267\u884c\u6982\u51b5\u6765\u4f18\u5316\u5e94\u7528\u7a0b\u5e8f\u7684\u4ee3\u7801\u5e03\u5c40\uff0c\u4ece\u800c\u5b9e\u73b0\u6539\u8fdb\u3002 clang \u4e00\u4e2a\u4e0e GCC \u517c\u5bb9\u7684 C \u5bb6\u65cf\uff08C, C++, Objective C/C++, OpenCL, CUDA\uff09\u7f16\u8bd1\u5668\u524d\u7aef\uff0c\u4ee5\u53ef\u89c2\u7684\u7f16\u8bd1\u65f6\u95f4\u4e0e\u826f\u597d\u7684\u8bca\u65ad\u4fe1\u606f\u800c\u8457\u540d\u3002 libcxx C++ \u6807\u51c6\u5e93\u7684\u4e00\u4e2a\u65b0\u5b9e\u73b0\uff0c\u9488\u5bf9 C++11 \u53ca\u4ee5\u4e0a\u7248\u672c\u3002 llvm LLVM \u9879\u76ee\u7684\u6838\u5fc3\uff0c\u5305\u62ec LLVM \u4e2d\u95f4\u8868\u793a\uff0c\u5404\u79cd\u4f18\u5316\u53ca\u5176\u5bf9\u5e94\u7684\u547d\u4ee4\u884c\u5de5\u5177\u3002 mlir \u4e00\u4e2a\u7528\u4e8e\u7f16\u5199\u7f16\u8bd1\u5668\u4e2d\u5404\u7c7b\u5206\u6790\u4e0e\u53d8\u6362\u53ca\u5176\u6240\u9700\u7684\u4e2d\u95f4\u8868\u793a\u7684\u901a\u7528\u6846\u67b6\u3002 lld \u4e00\u4e2a\u9ad8\u6027\u80fd\uff0c\u6a21\u5757\u5316\u7684\u8de8\u5e73\u53f0\u94fe\u63a5\u5668\u3002","title":"LLVM"},{"location":"llvm/overview/index.zh/#llvm-\u7684\u8bbe\u8ba1\u7406\u5ff5","text":"LLVM \u662f\u6a21\u5757\u5316\u7684\u3002 LLVM \u6700\u91cd\u8981\u7684\u65b9\u9762\u662f\u5b83\u88ab\u8bbe\u8ba1\u4e3a\u4e00\u7ec4\u5e93\uff0c\u800c\u4e0d\u662f\u50cf GCC \u90a3\u6837\u7684\u5355\u4e00\u547d\u4ee4\u884c\u7f16\u8bd1\u5668\u6216\u50cf JVM \u6216 .NET \u865a\u62df\u673a\u90a3\u6837\u7684\u4e0d\u900f\u660e\u865a\u62df\u673a\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c LLVM \u4f18\u5316\u5668\u63d0\u4f9b\u4e86\u5927\u91cf pass \uff0c\u5b83\u4eec\u88ab\u7f16\u8bd1\u6210\u4e00\u4e2a\u6216\u591a\u4e2a .o \u6587\u4ef6\uff0c\u7136\u540e\u88ab\u6784\u5efa\u6210\u4e00\u7cfb\u5217\u9759\u6001\u6216\u52a8\u6001\u5e93\u3002\u8fd9\u4e9b\u5e93\u63d0\u4f9b\u5404\u79cd\u5206\u6790\u548c\u8f6c\u6362\u529f\u80fd\uff0c\u5e76\u4e14 pass \u4e4b\u95f4\u5c3d\u53ef\u80fd\u4fdd\u6301\u72ec\u7acb\uff0c\u6216\u8005\u5982\u679c\u5b83\u4eec\u4f9d\u8d56\u4e8e\u5176\u4ed6\u5206\u6790\u6765\u5b8c\u6210\u5176\u5de5\u4f5c\uff0c\u5219\u660e\u786e\u58f0\u660e\u5b83\u4eec\u4e0e\u5176\u4ed6 pass \u4e4b\u95f4\u7684\u4f9d\u8d56\u5173\u7cfb\u3002\u800c\u5728 LLVM \u4f18\u5316\u5b9e\u9645\u7684\u4f18\u5316\u8fc7\u7a0b\u4e2d\uff0c\u53ea\u6709\u88ab\u4f7f\u7528\u7684 pass \u4f1a\u88ab\u94fe\u63a5\u5230\u6700\u7ec8\u5e94\u7528\u7a0b\u5e8f\uff0c\u800c\u4e0d\u662f\u6240\u6709\u7684\u3002 \u8fd9\u79cd\u76f4\u63a5\u7684\u8bbe\u8ba1\u65b9\u6cd5\u5141\u8bb8 LLVM \u63d0\u4f9b\u5927\u91cf\u7684\u529f\u80fd\uff0c\u5176\u4e2d\u4e00\u4e9b\u53ef\u80fd\u53ea\u5bf9\u7279\u5b9a\u7684\u53d7\u4f17\u6709\u7528\uff0c\u800c\u4e0d\u4f1a\u5f71\u54cd\u5230\u53ea\u60f3\u505a\u5176\u4ed6\u7b80\u5355\u4e8b\u60c5\u7684\u5e93\u7684\u7528\u6237\u3002\u76f8\u6bd4\u4e4b\u4e0b\uff0c\u4f20\u7edf\u7684\u7f16\u8bd1\u5668\u4f18\u5316\u5668\u662f\u4f5c\u4e3a\u5927\u91cf\u76f8\u4e92\u5173\u8054\u7684\u4ee3\u7801\u6784\u5efa\u7684\uff0c\u5f88\u96be\u5bf9\u5176\u8fdb\u884c\u5b50\u96c6\u5316\u3001\u63a8\u7406\u548c\u52a0\u901f\u3002\u4f7f\u7528 LLVM\uff0c\u60a8\u53ef\u4ee5\u5728\u4e0d\u77e5\u9053\u6574\u4e2a\u7cfb\u7edf\u5982\u4f55\u7ec4\u5408\u5728\u4e00\u8d77\u7684\u60c5\u51b5\u4e0b\u4e86\u89e3\u5404\u4e2a\u4f18\u5316\u5668\u3002","title":"LLVM \u7684\u8bbe\u8ba1\u7406\u5ff5"},{"location":"llvm/overview/index.zh/#\u7f16\u8bd1\u5668\u7684\u6d41\u7a0b\u4ee5-clangllvm-\u4e3a\u4f8b","text":"\u901a\u5e38\u6765\u8bf4\uff0c\u7f16\u8bd1\u5668\u5206\u4e3a\u524d\u7aef\uff0c\u4e2d\u7aef\u4e0e\u540e\u7aef\u3002 \u524d\u7aef\u7684\u804c\u8d23\u4e3b\u8981\u5728\u4e8e\u5bf9\u6e90\u4ee3\u7801\u8fdb\u884c\u5206\u6790\u548c\u5904\u7406\u5e76\u751f\u6210\u4e2d\u95f4\u4ee3\u7801\u3002","title":"\u7f16\u8bd1\u5668\u7684\u6d41\u7a0b\uff08\u4ee5 Clang/LLVM \u4e3a\u4f8b\uff09"},{"location":"llvm/overview/index.zh/#\u8bcd\u6cd5\u5206\u6790","text":"\u5728\u8fd9\u4e2a\u9636\u6bb5\uff0c\u7f16\u8bd1\u5668\u4f1a\u5c06\u6e90\u4ee3\u7801\u5206\u6210\u4e00\u4e2a\u4e2a\u7684 token\uff0c\u5e76\u5ffd\u7565\u6389\u8bf8\u5982\u7a7a\u683c\u7a7a\u884c\u7b49\u65e0\u6548\u4fe1\u606f\u3002\u6bcf\u4e2a token \u901a\u5e38\u5305\u542b\u4ee5\u4e0b\u4fe1\u606f\uff1a \u7c7b\u578b\u3002\u5e38\u89c1\u7684\u7c7b\u578b\u5982\u6807\u8bc6\u7b26\u3001\u5173\u952e\u8bcd\u3001\u5206\u9694\u7b26\u3001\u8fd0\u7b97\u7b26\u3001\u5b57\u9762\u91cf\u7b49\u3002 \u503c\u3002\u6b64 token \u5b9e\u9645\u5bf9\u5e94\u7684\u503c\u3002 \u6e90\u4ee3\u7801\u4e2d\u7684\u4f4d\u7f6e\u3002\u8bb0\u5f55 token \u5728\u539f\u59cb\u4ee3\u7801\u4e2d\u7684\u4f4d\u7f6e\u53ef\u5e2e\u52a9\u6211\u4eec\u751f\u6210\u66f4\u597d\u7684\u8bca\u65ad\u4fe1\u606f\u3002 \u4e3e\u4e2a\u4f8b\u5b50: 1 2 3 4 5 6 7 8 int foo ( int i ) { return i + 42 ; } int main () { int x = foo ( 24 ); return x - 24 ; } \u5bf9\u4e8e\u4ee5\u4e0a\u4ee3\u7801\uff0cClang \u4f1a\u751f\u6210\u5982\u4e0b token: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $ clang -c -Xclang -dump-tokens prog.c int 'int' [ StartOfLine ] Loc = <prog.c:1:1> identifier 'foo' [ LeadingSpace ] Loc = <prog.c:1:5> l_paren '(' Loc = <prog.c:1:8> int 'int' Loc = <prog.c:1:9> identifier 'i' [ LeadingSpace ] Loc = <prog.c:1:13> r_paren ')' Loc = <prog.c:1:14> l_brace '{' [ LeadingSpace ] Loc = <prog.c:1:16> return 'return' [ LeadingSpace ] Loc = <prog.c:1:18> identifier 'i' [ LeadingSpace ] Loc = <prog.c:1:25> plus '+' [ LeadingSpace ] Loc = <prog.c:1:27> numeric_constant '42' [ LeadingSpace ] Loc = <prog.c:1:29> semi ';' Loc = <prog.c:1:31> r_brace '}' [ LeadingSpace ] Loc = <prog.c:1:33> int 'int' [ StartOfLine ] Loc = <prog.c:3:1> identifier 'main' [ LeadingSpace ] Loc = <prog.c:3:5> l_paren '(' Loc = <prog.c:3:9> r_paren ')' Loc = <prog.c:3:10> l_brace '{' [ LeadingSpace ] Loc = <prog.c:3:12> int 'int' [ StartOfLine ] [ LeadingSpace ] Loc = <prog.c:4:3> identifier 'x' [ LeadingSpace ] Loc = <prog.c:4:7> equal '=' [ LeadingSpace ] Loc = <prog.c:4:9> identifier 'foo' [ LeadingSpace ] Loc = <prog.c:4:11> l_paren '(' Loc = <prog.c:4:14> numeric_constant '24' Loc = <prog.c:4:15> r_paren ')' Loc = <prog.c:4:17> semi ';' Loc = <prog.c:4:18> return 'return' [ StartOfLine ] [ LeadingSpace ] Loc = <prog.c:5:3> identifier 'x' [ LeadingSpace ] Loc = <prog.c:5:10> minus '-' [ LeadingSpace ] Loc = <prog.c:5:12> numeric_constant '24' [ LeadingSpace ] Loc = <prog.c:5:14> semi ';' Loc = <prog.c:5:16> r_brace '}' [ StartOfLine ] Loc = <prog.c:6:1> eof '' Loc = <prog.c:6:2>","title":"\u8bcd\u6cd5\u5206\u6790"},{"location":"llvm/overview/index.zh/#\u8bed\u6cd5\u5206\u6790","text":"\u5728\u8fd9\u4e2a\u9636\u6bb5\uff0c\u7f16\u8bd1\u5668\u4f1a\u5c06\u7ebf\u6027\u7684 token \u6d41\u8f6c\u6362\u4e3a\u5177\u6709\u7279\u5b9a\u8bed\u6cd5\u89c4\u5219\u7684\u62bd\u8c61\u8bed\u6cd5\u6811\uff08Abstract Syntax Tree\uff09\u3002\u5982\u679c\u5728\u8bed\u6cd5\u89e3\u6790\u4e2d\u51fa\u73b0\u9519\u8bef\uff0c\u7f16\u8bd1\u5668\u4e5f\u4f1a\u5728\u8fd9\u4e2a\u9636\u6bb5\u629b\u51fa\u4e00\u4e2a\u8bca\u65ad\u3002 \u5bf9\u4e8e\u524d\u9762\u7684\u4ee3\u7801\uff0c\u53ef\u4ee5\u7528\u4ee5\u4e0b\u547d\u4ee4\u67e5\u770b Clang \u6240\u751f\u6210\u7684\u8bed\u6cd5\u6811\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ clang -Xclang -ast-dump -fsyntax-only prog.c TranslationUnitDecl 0x820688 <<invalid sloc>> <invalid sloc> | -FunctionDecl 0x877270 <prog.c:1:1, col:33> col:5 used foo 'int (int)' | | -ParmVarDecl 0x8771a0 <col:9, col:13> col:13 used i 'int' | ` -CompoundStmt 0x8773e8 <col:16, col:33> | ` -ReturnStmt 0x8773d8 <col:18, col:29> | ` -BinaryOperator 0x8773b8 <col:25, col:29> 'int' '+' | | -ImplicitCastExpr 0x8773a0 <col:25> 'int' <LValueToRValue> | | ` -DeclRefExpr 0x877360 <col:25> 'int' lvalue ParmVar 0x8771a0 'i' 'int' | ` -IntegerLiteral 0x877380 <col:29> 'int' 42 ` -FunctionDecl 0x877450 <line:3:1, line:6:1> line:3:5 main 'int ()' ` -CompoundStmt 0x8776b8 <col:12, line:6:1> | -DeclStmt 0x877618 <line:4:3, col:18> | ` -VarDecl 0x877508 <col:3, col:17> col:7 used x 'int' cinit | ` -CallExpr 0x8775f0 <col:11, col:17> 'int' | | -ImplicitCastExpr 0x8775d8 <col:11> 'int (*)(int)' <FunctionToPointerDecay> | | ` -DeclRefExpr 0x877570 <col:11> 'int (int)' Function 0x877270 'foo' 'int (int)' | ` -IntegerLiteral 0x877590 <col:15> 'int' 24 ` -ReturnStmt 0x8776a8 <line:5:3, col:14> ` -BinaryOperator 0x877688 <col:10, col:14> 'int' '-' | -ImplicitCastExpr 0x877670 <col:10> 'int' <LValueToRValue> | ` -DeclRefExpr 0x877630 <col:10> 'int' lvalue Var 0x877508 'x' 'int' ` -IntegerLiteral 0x877650 <col:14> 'int' 24","title":"\u8bed\u6cd5\u5206\u6790"},{"location":"llvm/overview/index.zh/#\u4e2d\u95f4\u4ee3\u7801\u751f\u6210","text":"\u5728\u8fd9\u4e2a\u9636\u6bb5\uff0c\u7f16\u8bd1\u5668\u4f1a\u5c06\u62bd\u8c61\u8bed\u6cd5\u6811\u8f6c\u6362\u4e3a\u4e2d\u95f4\u8868\u793a\u3002 \u8fd8\u662f\u4e0a\u9762\u7684\u4f8b\u5b50\uff0cClang \u4f1a\u751f\u6210\u4ee5\u4e0b\u4e2d\u95f4\u8868\u793a\uff08LLVM IR\uff09\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ; ModuleID = 'prog.c' source_filename = \"prog.c\" target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\" target triple = \"x86_64-pc-linux-gnu\" ; Function Attrs: noinline nounwind optnone define dso_local i32 @foo ( i32 noundef %i ) #0 { entry: %i.addr = alloca i32 , align 4 store i32 %i , i32 * %i.addr , align 4 %0 = load i32 , i32 * %i.addr , align 4 %add = add nsw i32 %0 , 42 ret i32 %add } ; Function Attrs: noinline nounwind optnone define dso_local i32 @main () #0 { entry: %retval = alloca i32 , align 4 %x = alloca i32 , align 4 store i32 0 , i32 * %retval , align 4 %call = call i32 @foo ( i32 noundef 24 ) store i32 %call , i32 * %x , align 4 %0 = load i32 , i32 * %x , align 4 %sub = sub nsw i32 %0 , 24 ret i32 %sub } \u4e2d\u7aef\u4e3b\u8981\u8d1f\u8d23\u5728\u4e2d\u95f4\u4ee3\u7801\u4e0a\u8fdb\u884c\u5206\u6790\u548c\u4f18\u5316\uff0c\u751f\u6210\u66f4\u9ad8\u6548\u7684\u4e2d\u95f4\u4ee3\u7801\u3002\u9664\u4e86\u901a\u7528\u7684\u4f18\u5316\uff0c\u4e2d\u7aef\u4e5f\u5305\u542b\u4e86\u90a3\u4e9b\u5e73\u53f0\u76f8\u5173\u7684\u7279\u6b8a\u4f18\u5316\u3002 \u4e2d\u7aef\u7684\u5177\u4f53\u804c\u8d23\u5305\u542b\uff1a \u5bf9\u4e2d\u95f4\u8868\u793a\u8fdb\u884c\u5206\u6790\uff0c\u5982\u6570\u636e\u6d41\u5206\u6790\uff0c\u522b\u540d\u5206\u6790\u7b49\u3002\u6b64\u9636\u6bb5\u662f\u7f16\u8bd1\u5668\u8fdb\u884c\u5176\u4ed6\u4f18\u5316\u7684\u57fa\u7840\u3002 \u4f18\u5316\u4e2d\u95f4\u8868\u793a\uff0c\u5c06\u5176\u8868\u8ff0\u88ab\u8f6c\u5316\u4e3a\u529f\u80fd\u7b49\u540c\u4f46\u66f4\u5feb\uff08\u6216\u66f4\u5c0f\uff09\u7684\u5f62\u5f0f\u3002\u5e38\u89c1\u7684\u4f18\u5316\u5982\u5185\u8054\u5c55\u5f00\uff0c\u6b7b\u4ee3\u7801\u6d88\u9664\uff0c\u5e38\u91cf\u4f20\u64ad\u3001\u5faa\u73af\u8f6c\u6362\u7b49\u3002 \u4f8b\u5982\u6211\u4eec\u6709\u8fd9\u4e48\u4e00\u6bb5 LLVM IR: 1 2 3 4 5 6 7 $ cat prog . ll define void @test ( ptr %Q , ptr %P ) { %DEAD = load i32 , ptr %Q store i32 %DEAD , ptr %P store i32 0 , ptr %P ret void } \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 LLVM \u63d0\u4f9b\u7684\u547d\u4ee4\u884c\u5de5\u5177\u5bf9\u5176\u8fdb\u884c\u4e00\u6bb5\u4efb\u610f\u7684\u4f18\u5316\u3002\u901a\u8fc7\u914d\u5408 Unix \u7cfb\u7edf\u4e0a\u7684\u7ba1\u9053\u7b26\uff0c\u6211\u4eec\u53ef\u4ee5\u975e\u5e38\u7075\u6d3b\u5730\u8fbe\u5230\u5404\u79cd\u6548\u679c\uff1a 1 2 3 4 5 6 7 8 $ opt -passes = dse prog.ll | llvm-dis -f ; ModuleID = '<stdin>' source_filename = \"prog.ll\" define void @test ( ptr %Q, ptr %P ) { store i32 0 , ptr %P, align 4 ret void } \u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u4e86 LLVM \u63d0\u4f9b\u7684 opt \u5de5\u5177\u5355\u72ec\u5bf9 prog.ll \u4f7f\u7528\u4e86\u6b7b\u4ee3\u7801\u6d88\u9664\u7684\u4f18\u5316\u3002\u7531\u4e8e opt \u4f1a\u751f\u6210\u4eba\u7c7b\u4e0d\u53ef\u9605\u8bfb\u7684 LLVM \u5b57\u8282\u7801\uff0c\u6211\u4eec\u63a5\u7740\u53c8\u4f7f\u7528\u4e86 llvm-dis \u5c06\u5176\u8f6c\u6362\u4e3a LLVM IR\u3002 \u540e\u7aef\u9700\u8981\u5c06\u4e2d\u95f4\u4ee3\u7801\u751f\u6210\u5bf9\u5e94\u5e73\u53f0\u7684\u673a\u5668\u4ee3\u7801\uff0c\u4ee5\u53ca\u8fdb\u884c\u4e00\u4e9b\u4f53\u7cfb\u67b6\u6784\u7684\u7ec6\u8282\u7684\u4f18\u5316\u3002","title":"\u4e2d\u95f4\u4ee3\u7801\u751f\u6210"},{"location":"llvm/overview/index.zh/#\u5982\u4f55\u7ed9-llvm-\u505a\u8d21\u732e","text":"","title":"\u5982\u4f55\u7ed9 LLVM \u505a\u8d21\u732e"},{"location":"llvm/overview/index.zh/#\u63d0\u4ea4\u65b0-bug","text":"\u5728\u8fc7\u53bb\u7684\u5f88\u957f\u4e00\u6bb5\u65f6\u95f4\u91cc\uff0cLLVM \u4e00\u76f4\u4f7f\u7528 Bugzilla \u4f5c\u4e3a\u5176 Bug tracker\uff0c\u4f46\u662f\u73b0\u5728\u5df2\u8f6c\u5411 Github issues \u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u67e5\u770b issue \u4e2d\u7684 Good Frist Issue \u6765\u5bfb\u627e\u4e00\u4e9b\u5bb9\u6613\u4e0a\u624b\u7684 Bug\u3002","title":"\u63d0\u4ea4\u65b0 Bug"},{"location":"llvm/overview/index.zh/#\u63d0\u4ea4\u8865\u4e01","text":"Note \u6ce8\u610f\uff0cLLVM \u6709\u610f\u5411\u653e\u5f03 Phabricator \u5e76\u8f6c\u5411 Github Pull Requests\uff0c\u8be6\u89c1 [^Code Review Process Update]\u3002 \u76ee\u524d\uff0cLLVM \u8fd8\u4e3b\u8981\u4f7f\u7528 Phabricator \u6765\u63d0\u4ea4\u8865\u4e01\u8fdb\u884c\u4ee3\u7801\u5ba1\u67e5\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 Github \u7b49\u7b2c\u4e09\u65b9\u8d26\u53f7\u5feb\u901f\u6ce8\u518c\u4e00\u4e2a Phabricator \u8d26\u53f7\u3002 \u60a8\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u7f51\u9875\u6216 Phabricator \u81ea\u5e26\u7684\u547d\u4ee4\u884c\u5de5\u5177 arcanist \u6765\u63d0\u4ea4\u60a8\u7684\u8865\u4e01\u3002\u5177\u4f53\u6587\u6863\u53ef\u53c2\u8003 \u8fd9\u91cc \u3002\u4e0b\u9762\u662f\u4f7f\u7528 arcanist \u7684\u7b80\u5355\u793a\u4f8b\uff1a Note \u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u60a8\u4f7f\u7528\u7684\u662f Unix-like \u7684\u64cd\u4f5c\u7cfb\u7edf\u5e76\u5df2\u5b89\u88c5\u5e76\u914d\u7f6e\u597d\u4e86 Git \u9996\u5148\u6211\u4eec\u9700\u8981\u5b89\u88c5 arcanist\uff1a 1 git clone https://github.com/phacility/arcanist.git \u63a5\u7740\u5c06\u5176\u6dfb\u52a0\u5230\u73af\u5883\u53d8\u91cf\u4e2d\uff1a 1 export PATH = \" $PATH :/path/to/arcanist/bin/\" \u6388\u6743\u767b\u9646\uff1a 1 arc install-certificate \u5728\u8fdb\u884c\u7f16\u7801\u65f6\uff0c\u6211\u4eec\u63a8\u8350\u4f7f\u7528 amend \u6216\u624b\u52a8 rebase \u5c06\u6211\u4eec\u7684\u4ee3\u7801\u538b\u7f29\u6210\u4e00\u4e2a commit \uff0c\u65b9\u4fbf\u540e\u7eed\u7684\u4ee3\u7801\u5ba1\u67e5\u3002 \u5f53\u6211\u4eec\u7684 patch \u5728\u672c\u5730\u901a\u8fc7\u6d4b\u8bd5\u540e\uff0c\u4fbf\u53ef\u4ee5\u51c6\u5907\u53d1\u51fa\u53bb\u4e86\u3002\u4f46\u5728\u6b64\u4e4b\u524d\u4e00\u5b9a\u8981\u6ce8\u610f\u7528 clang-format \u4fdd\u8bc1\u6211\u4eec\u7684 patch \u7b26\u5408 LLVM Coding Style\u3002 \u5efa\u8bae\u4f7f\u7528 LLVM \u5b98\u65b9\u63d0\u4f9b\u7684 git-clang-format \u5de5\u5177\uff0c\u6548\u679c\u6700\u597d\uff0c\u907f\u514d\u610f\u5916\u4fee\u6539\u5230\u5176\u4ed6\u7684\u4ee3\u7801\u3002 \u53ef\u4ee5\u76f4\u63a5\u5c06 git-clang-format \u6240\u5728\u7684\u8def\u5f84\u6dfb\u52a0\u5230 PATH \u4e2d\u5c31\u53ef\u4ee5\u4e86\u3002 1 git clang-format HEAD~1 \u6ce8\u610fformat\u540e\u5e76\u4e0d\u4f1a\u81ea\u52a8\u63d0\u4ea4\uff0c\u6240\u4ee5\u60a8\u9700\u8981\uff1a 1 git commit --amend -a \u5728\u4e0a\u8ff0\u5de5\u4f5c\u5b8c\u6210\u540e\uff0c\u6211\u4eec\u4fbf\u53ef\u4ee5\u4f7f\u7528 arc \u63d0\u4ea4\u8865\u4e01\u5230 Phabricator \u4e86\uff1a 1 arc diff arcanist \u4f1a\u5c06\u6700\u8fd1\u7684\u4e00\u4e2a\u63d0\u4ea4\u4e0a\u4f20\u5230 Phabricator \u4e0a\uff0c\u6210\u529f\u540e\u5b83\u4f1a\u7ed9\u6211\u4eec\u4e00\u4e2a\u94fe\u63a5\uff0c\u8fd9\u4fbf\u662f\u6211\u4eec\u7684 Revision \u5566\u3002 \u5728 reviewer \u770b\u8fc7\u4ee3\u7801\u540e\uff0c\u53ef\u80fd\u4f1a\u7ed9\u6211\u4eec\u4e00\u4e9b\u4fee\u6539\u7684\u5efa\u8bae\uff0c\u6211\u4eec\u53ef\u4ee5\u7ee7\u7eed\u4f7f\u7528 arcanist \u66f4\u65b0\u6211\u4eec\u7684\u8865\u4e01: 1 arc diff --update DXXXXX \u5176\u4e2d DXXXXX \u662f\u6211\u4eec\u4e4b\u524d\u7684 Revision\uff0c\u56e0\u4e3a arcanist \u65e0\u6cd5\u77e5\u9053\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u624b\u52a8\u6307\u5b9a\u3002","title":"\u63d0\u4ea4\u8865\u4e01"},{"location":"llvm/overview/index.zh/#\u4e0e\u793e\u533a\u6c9f\u901a","text":"\u90ae\u4ef6\u5217\u8868 \u5c3d\u7ba1\u793e\u533a\u5df2\u9010\u6b65\u6dd8\u6c70\u4e86\u90ae\u4ef6\u5217\u8868\uff0c\u6211\u4eec\u4ecd\u5efa\u8bae\u60a8\u8ba2\u9605\u5bf9\u5e94\u5b50\u9879\u76ee\u7684\u63d0\u4ea4\u8bb0\u5f55\u5217\u8868\uff0c\u8fd9\u6709\u52a9\u4e8e\u5e2e\u52a9\u60a8\u4e86\u89e3\u9879\u76ee\u4e2d\u6b63\u5728\u53d1\u751f\u7684\u4e8b\u60c5\u3002\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5982\u679c\u60a8\u60f3\u5411 Clang \u505a\u8d21\u732e\uff0c\u60a8\u53ef\u4ee5\u8ba2\u9605 cfe-commits \u8fd9\u4e2a\u5217\u8868\uff0c\u5982\u679c\u60a8\u60f3\u5411 LLVM \u6838\u5fc3\u505a\u8d21\u732e\uff0c\u53ef\u8ba2\u9605 llvm-commits \u8fd9\u4e2a\u5217\u8868\u3002 Discourse Discord","title":"\u4e0e\u793e\u533a\u6c9f\u901a"},{"location":"llvm/overview/index.zh/#\u76f8\u5173\u94fe\u63a5","text":"Getting Started with the LLVM System The Design Decisions of LLVM LLVM Language Reference Manual LLVM IR Tutorial - Phis, GEPs and other things, oh my! 2019 LLVM Developers\u2019 Meeting: E. Christopher & J. Doerfert \u201cIntroduction to LLVM\u201d \u201cClang\u201d CFE Internals Manual 2019 LLVM Developers\u2019 Meeting: S. Haastregt & A. Stulova \u201cAn overview of Clang \u201d P. Goldsborough \u201cclang-useful: Building useful tools with LLVM and clang for fun and profit\" \u60a8\u53ef\u4ee5\u53c2\u8003 \u672c\u5e16 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002 \u21a9","title":"\u76f8\u5173\u94fe\u63a5"},{"location":"llvm/pass/","text":"Pass The LLVM pass framework is an important part of the LLVM system, because LLVM passes are where the most interesting parts of the compiler exist. Passes perform transformations and optimizations that make up the compiler, they build the analysis results that are used by these transformations, and they are, above all, a structuring technique for compiler code. An LLVM pass can be regarded as a black box that takes LLVM IR as input and produces outputs depending on what kind the pass is. There're two kinds of passes: transformation pass and analysis pass . For a transformation pass, it typically modifies the input IR and produces the transformed IR. Code generation passes that output SelectionDAG and machine IR from input LLVM IR are also transformation passes. For an analysis pass, it does not modify the input IR, but it looks into the IR and produces certain information that describes some properties about the input IR. Transformation passes typically implement compiler optimizations, program transformation, program instrumentation and other tasks. Analysis passes typically provide necessary information for the transformation passes to work. Real-world compilers usually rely on hundreds of passes that run one after another on the generated IR to complete optimization and code generation. This sequence of passes that run one after another is also called the pipeline . Note that different compiler configurations may end with different pipeline configurations, affecting the set of passes used and their execution order. Passes can have dependencies . For example, a transformation pass cannot work until its required analysis passes have been run. Also, some transformation passes can invalidate cached code properties analyzed by a previous analysis pass. LLVM uses pass managers to manage available passes and schedule the pass pipeline properly onto the input IR. Unfortunately, due to historical reasons, LLVM has two flavors of pass managers at now: the new pass manager and the legacy pass manager. This wiki primarily talks about the new pass manager, and the LLVM community is migrating to the new pass manager and deprecating the legacy one.","title":"llvm-pass-overview"},{"location":"llvm/pass/#pass","text":"The LLVM pass framework is an important part of the LLVM system, because LLVM passes are where the most interesting parts of the compiler exist. Passes perform transformations and optimizations that make up the compiler, they build the analysis results that are used by these transformations, and they are, above all, a structuring technique for compiler code. An LLVM pass can be regarded as a black box that takes LLVM IR as input and produces outputs depending on what kind the pass is. There're two kinds of passes: transformation pass and analysis pass . For a transformation pass, it typically modifies the input IR and produces the transformed IR. Code generation passes that output SelectionDAG and machine IR from input LLVM IR are also transformation passes. For an analysis pass, it does not modify the input IR, but it looks into the IR and produces certain information that describes some properties about the input IR. Transformation passes typically implement compiler optimizations, program transformation, program instrumentation and other tasks. Analysis passes typically provide necessary information for the transformation passes to work. Real-world compilers usually rely on hundreds of passes that run one after another on the generated IR to complete optimization and code generation. This sequence of passes that run one after another is also called the pipeline . Note that different compiler configurations may end with different pipeline configurations, affecting the set of passes used and their execution order. Passes can have dependencies . For example, a transformation pass cannot work until its required analysis passes have been run. Also, some transformation passes can invalidate cached code properties analyzed by a previous analysis pass. LLVM uses pass managers to manage available passes and schedule the pass pipeline properly onto the input IR. Unfortunately, due to historical reasons, LLVM has two flavors of pass managers at now: the new pass manager and the legacy pass manager. This wiki primarily talks about the new pass manager, and the LLVM community is migrating to the new pass manager and deprecating the legacy one.","title":"Pass"},{"location":"llvm/pass/hello-world/","text":"Write a Hello World Pass In this section, we guide you through writing and running a simple pass that prints the names of all functions contained in the input IR module. Setup the Build Let's assume that you have cloned the LLVM monorepo and setup the build directory at build/ 1 , and the current working directory is the root of the monorepo. In this section, we will build the new pass in-tree, which means that the source tree of the new pass is directly embedded in the source tree of the LLVM monorepo. Create a Hello.h file under llvm/include/llvm/Transforms/Utils/ : 1 touch llvm/include/llvm/Transforms/Utils/Hello.h Create a Hello.cpp file under llvm/lib/Transforms/Utils/ : 1 touch llvm/lib/Transforms/Utils/Hello.cpp Modify llvm/lib/Transforms/Utils/CMakeLists.txt and add Hello.cpp to the add_llvm_component_library call: 1 2 3 4 5 add_llvm_component_library ( LLVMTransformUtils # Other files ... Hello.cpp # Other files and configurations ... ) This step adds Hello.cpp to the LLVM build process. Code Implementation Edit Hello.h as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #ifndef LLVM_TRANSFORMS_HELLO_H #define LLVM_TRANSFORMS_HELLO_H #include \"llvm/IR/PassManager.h\" namespace llvm { class HelloPass : public PassInfoMixin < HelloPass > { public : PreservedAnalyses run ( Function & F , FunctionAnalysisManager & AM ); }; } // namespace llvm #endif Edit Hello.cpp as follows: 1 2 3 4 5 6 7 8 9 10 #include \"llvm/Transforms/Utils/Hello.h\" namespace llvm { PreservedAnalyses HelloPass::run ( Function & F , FunctionAnalysisManager & AM ) { errs () << F . getName () << \" \\n \" ; return PreservedAnalyses :: all (); } } // namespace llvm Yes! This is (almost) all you need to write a simple but working pass. Let's break the code into pieces and see how it's working. To create a pass in C++, you need to write a class that implements the software interface of a pass. Unlike traditional approaches which rely on class inheritance, the new pass manager uses concepts-based polymorphism 2 3 . As long as the class contains a run method that allows it to run on some piece of IR, it is a pass . No need to inherit the class from some base class and override some virtual functions. In the code above, our HelloPass class inherits from the PassInfoMixin class, which adds some boilerplate code to the pass. But the most important part is the run method that makes HelloPass a pass. The run method takes two parameters. The first parameter F is the IR function that the pass is running on. Note that F is passed via a non-const reference, indicating that we can modify the function (i.e. perform transformations) in the pass. The second parameter AM is a pass manager instance that links to analysis passes and provides function-level analysis information. Since the run method takes Function as input, HelloPass is a function pass . The pass manager schedules a function pass to run on every function in the input IR module. When the HelloPass gets executed, it writes the function's name to the standard error and finishes. The run method returns a PreservedAnalyses object. This object contains information about whether the analysis performed by a previous analysis pass is still valid after this pass runs. The run method returns PreservedAnalyses::all() to indicate that all available analysis is still valid after running HelloPass (because it doesn't modify the IR). Register the Pass We have finished implementing the simple pass but we havn't told LLVM pass manager about the existance of our new pass. We need to register our new pass into the pass manager. Edit llvm/lib/Passes/PassRegistry.def and add the following lines to it: 1 FUNCTION_PASS ( \"hello\" , HelloPass ()) Note the first argument to FUNCTION_PASS is the name of our new pass. Add the following #include to llvm/lib/Passes/PassBuilder.cpp : 1 #include \"llvm/Transforms/Utils/Hello.h\" and it's done. Now time for building and running our new pass. Build and Run Go to the build directory and build opt , which is a dedicated tool for running passes over a piece of IR. After building opt , create a test IR file test.ll for testing: 1 2 3 4 5 6 7 8 define i32 @foo () { %a = add i32 2 , 3 ret i32 %a } define void @bar () { ret void } Then run our new pass with opt : 1 build/bin/opt -disable-output test.ll -passes = hello The -passes=hello option make opt run HelloPass . Expected output: 1 2 foo bar Congratulations! You have finished your LLVM pass! For instructions on how to build LLVM from source, please refer to the official documentation . \u21a9 You can refer to this comment for a brief introduction to the concepts-based polymorphism used in the pass framework. \u21a9 For a detailed introduction and discussion about concepts-based polymorphism, please refer to GuillaumeDua. Concept-based polymorphism in modern C++ . \u21a9","title":"Hello World"},{"location":"llvm/pass/hello-world/#write-a-hello-world-pass","text":"In this section, we guide you through writing and running a simple pass that prints the names of all functions contained in the input IR module.","title":"Write a Hello World Pass"},{"location":"llvm/pass/hello-world/#setup-the-build","text":"Let's assume that you have cloned the LLVM monorepo and setup the build directory at build/ 1 , and the current working directory is the root of the monorepo. In this section, we will build the new pass in-tree, which means that the source tree of the new pass is directly embedded in the source tree of the LLVM monorepo. Create a Hello.h file under llvm/include/llvm/Transforms/Utils/ : 1 touch llvm/include/llvm/Transforms/Utils/Hello.h Create a Hello.cpp file under llvm/lib/Transforms/Utils/ : 1 touch llvm/lib/Transforms/Utils/Hello.cpp Modify llvm/lib/Transforms/Utils/CMakeLists.txt and add Hello.cpp to the add_llvm_component_library call: 1 2 3 4 5 add_llvm_component_library ( LLVMTransformUtils # Other files ... Hello.cpp # Other files and configurations ... ) This step adds Hello.cpp to the LLVM build process.","title":"Setup the Build"},{"location":"llvm/pass/hello-world/#code-implementation","text":"Edit Hello.h as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #ifndef LLVM_TRANSFORMS_HELLO_H #define LLVM_TRANSFORMS_HELLO_H #include \"llvm/IR/PassManager.h\" namespace llvm { class HelloPass : public PassInfoMixin < HelloPass > { public : PreservedAnalyses run ( Function & F , FunctionAnalysisManager & AM ); }; } // namespace llvm #endif Edit Hello.cpp as follows: 1 2 3 4 5 6 7 8 9 10 #include \"llvm/Transforms/Utils/Hello.h\" namespace llvm { PreservedAnalyses HelloPass::run ( Function & F , FunctionAnalysisManager & AM ) { errs () << F . getName () << \" \\n \" ; return PreservedAnalyses :: all (); } } // namespace llvm Yes! This is (almost) all you need to write a simple but working pass. Let's break the code into pieces and see how it's working. To create a pass in C++, you need to write a class that implements the software interface of a pass. Unlike traditional approaches which rely on class inheritance, the new pass manager uses concepts-based polymorphism 2 3 . As long as the class contains a run method that allows it to run on some piece of IR, it is a pass . No need to inherit the class from some base class and override some virtual functions. In the code above, our HelloPass class inherits from the PassInfoMixin class, which adds some boilerplate code to the pass. But the most important part is the run method that makes HelloPass a pass. The run method takes two parameters. The first parameter F is the IR function that the pass is running on. Note that F is passed via a non-const reference, indicating that we can modify the function (i.e. perform transformations) in the pass. The second parameter AM is a pass manager instance that links to analysis passes and provides function-level analysis information. Since the run method takes Function as input, HelloPass is a function pass . The pass manager schedules a function pass to run on every function in the input IR module. When the HelloPass gets executed, it writes the function's name to the standard error and finishes. The run method returns a PreservedAnalyses object. This object contains information about whether the analysis performed by a previous analysis pass is still valid after this pass runs. The run method returns PreservedAnalyses::all() to indicate that all available analysis is still valid after running HelloPass (because it doesn't modify the IR).","title":"Code Implementation"},{"location":"llvm/pass/hello-world/#register-the-pass","text":"We have finished implementing the simple pass but we havn't told LLVM pass manager about the existance of our new pass. We need to register our new pass into the pass manager. Edit llvm/lib/Passes/PassRegistry.def and add the following lines to it: 1 FUNCTION_PASS ( \"hello\" , HelloPass ()) Note the first argument to FUNCTION_PASS is the name of our new pass. Add the following #include to llvm/lib/Passes/PassBuilder.cpp : 1 #include \"llvm/Transforms/Utils/Hello.h\" and it's done. Now time for building and running our new pass.","title":"Register the Pass"},{"location":"llvm/pass/hello-world/#build-and-run","text":"Go to the build directory and build opt , which is a dedicated tool for running passes over a piece of IR. After building opt , create a test IR file test.ll for testing: 1 2 3 4 5 6 7 8 define i32 @foo () { %a = add i32 2 , 3 ret i32 %a } define void @bar () { ret void } Then run our new pass with opt : 1 build/bin/opt -disable-output test.ll -passes = hello The -passes=hello option make opt run HelloPass . Expected output: 1 2 foo bar Congratulations! You have finished your LLVM pass! For instructions on how to build LLVM from source, please refer to the official documentation . \u21a9 You can refer to this comment for a brief introduction to the concepts-based polymorphism used in the pass framework. \u21a9 For a detailed introduction and discussion about concepts-based polymorphism, please refer to GuillaumeDua. Concept-based polymorphism in modern C++ . \u21a9","title":"Build and Run"},{"location":"llvm/pass/hello-world.zh/","text":"\u7f16\u5199\u4e00\u4e2a Hello World Pass \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u5e26\u9886\u60a8\u7f16\u5199\u5e76\u8fd0\u884c\u4e00\u4e2a\u975e\u5e38\u7b80\u5355\u7684 pass\uff0c\u8fd9\u4e2a pass \u53ef\u4ee5\u8f93\u51fa\u5728\u8f93\u5165\u7684 IR \u6a21\u5757\u4e2d\u5305\u542b\u7684\u6240\u6709\u51fd\u6570\u7684\u540d\u79f0\u3002 \u8bbe\u7f6e\u6784\u5efa\u73af\u5883 \u5047\u8bbe\u60a8\u5df2\u7ecf\u514b\u9686\u4e86 LLVM \u4ed3\u5e93 \u5e76\u5728 build \u76ee\u5f55\u4e0b\u8bbe\u7f6e\u597d\u4e86\u6784\u5efa\u6811 1 \uff0c\u5e76\u4e14\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u662f LLVM \u4ed3\u5e93\u7684\u6839\u76ee\u5f55\u3002\u672c\u8282\u4e2d\u6211\u4eec\u5c06\u5728\u6811\u5185\u6784\u5efa\u65b0\u7684 pass\uff0c\u8fd9\u610f\u5473\u7740\u65b0\u7684 pass \u7684\u6240\u6709\u4ee3\u7801\u90fd\u5305\u542b\u5728 LLVM \u4ed3\u5e93\u7684\u6e90\u4ee3\u7801\u76ee\u5f55\u4e0b\u3002 \u5728 llvm/include/llvm/Transforms/Utils/ \u4e0b\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a Hello.h \u7684\u6587\u4ef6\uff1a 1 touch llvm/include/llvm/Transforms/Utils/Hello.h \u5728 llvm/lib/Transforms/Utils/ \u4e0b\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a Hello.cpp \u7684\u6587\u4ef6\uff1a 1 touch llvm/lib/Transforms/Utils/Hello.cpp \u4fee\u6539 llvm/lib/Transforms/Utils/CMakeLists.txt \u5e76\u5c06 Hello.cpp \u52a0\u5165\u5230\u5bf9 add_llvm_component_library \u7684\u8c03\u7528\u4e2d\uff1a 1 2 3 4 5 add_llvm_component_library ( LLVMTransformUtils # Other files ... Hello.cpp # Other files and configurations ... ) \u8fd9\u4e00\u6b65\u662f\u4e3a\u4e86\u5c06 Hello.cpp \u6dfb\u52a0\u5230 LLVM \u7684\u6784\u5efa\u8fc7\u7a0b\u4e2d\u3002 \u4ee3\u7801\u5b9e\u73b0 \u5c06\u5982\u4e0b\u5185\u5bb9\u6dfb\u52a0\u5230 Hello.h \u4e2d\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #ifndef LLVM_TRANSFORMS_HELLO_H #define LLVM_TRANSFORMS_HELLO_H #include \"llvm/IR/PassManager.h\" namespace llvm { class HelloPass : public PassInfoMixin < HelloPass > { public : PreservedAnalyses run ( Function & F , FunctionAnalysisManager & AM ); }; } // namespace llvm #endif \u5c06\u5982\u4e0b\u5185\u5bb9\u6dfb\u52a0\u5230 Hello.cpp \u4e2d: 1 2 3 4 5 6 7 8 9 10 #include \"llvm/Transforms/Utils/Hello.h\" namespace llvm { PreservedAnalyses HelloPass::run ( Function & F , FunctionAnalysisManager & AM ) { errs () << F . getName () << \" \\n \" ; return PreservedAnalyses :: all (); } } // namespace llvm \u662f\u7684\uff01\u8fd9\u5c31\u662f\uff08\u51e0\u4e4e\uff09\u5168\u90e8\u4e3a\u4e86\u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684 pass \u60a8\u9700\u8981\u7f16\u5199\u7684\u4ee3\u7801\u3002\u8ba9\u6211\u4eec\u5c06\u8fd9\u6bb5\u4ee3\u7801\u8fdb\u4e00\u6b65\u5206\u89e3\u5e76\u770b\u770b\u5b83\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002 \u4e3a\u4e86\u4f7f\u7528 C++ \u521b\u5efa\u4e00\u4e2a pass\uff0c\u60a8\u9700\u8981\u7f16\u5199\u4e00\u4e2a\u5b9e\u73b0\u4e86 pass \u6240\u9700\u8981\u7684\u8f6f\u4ef6\u63a5\u53e3\u7684\u7c7b\u3002\u4f20\u7edf\u7684\u505a\u6cd5\u662f\u4ece\u67d0\u4e2a\u57fa\u7c7b\u6d3e\u751f\u51fa\u6765\u4e00\u4e2a\u7c7b\u5e76\u91cd\u5199\u67d0\u4e9b\u865a\u51fd\u6570\u4ee5\u5b9e\u73b0\u63a5\u53e3\uff0c\u4f46\u65b0\u7684 pass \u7ba1\u7406\u5668\u5e76\u6ca1\u6709\u91c7\u7528\u8fd9\u79cd\u65b9\u6cd5\uff0c\u800c\u662f\u91c7\u7528\u4e86\u4e00\u79cd\u88ab\u79f0\u4e3a \u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001 \uff08Concept-Based Polymorphism\uff09 2 3 \u7684\u65b9\u6cd5\u3002 \u53ea\u8981\u8fd9\u4e2a\u7c7b\u5305\u542b\u4e00\u4e2a\u540d\u4e3a run \u7684\u65b9\u6cd5\u4f7f\u4e4b\u53ef\u4ee5\u5728\u4e00\u6bb5 IR \u4e0a\u6267\u884c\uff0c\u90a3\u4e48\u8fd9\u4e2a\u7c7b\u5c31\u8868\u793a\u4e00\u4e2a pass\u3002 \u4e0d\u9700\u8981\u4ece\u67d0\u4e2a\u57fa\u7c7b\u6d3e\u751f\u51fa\u5b50\u7c7b\u6765\u8868\u793a\u4e00\u4e2a pass\u3002\u5728\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u7684 HelloPass \u7c7b\u7ee7\u627f\u81ea PassInfoMixin \u7c7b\uff0c\u8fd9\u4e2a\u57fa\u7c7b\u5411 HelloPass \u63d0\u4f9b\u7684\u63a5\u53e3\u4e2d\u53c8\u989d\u5916\u6dfb\u52a0\u4e86\u4e00\u4e9b\u901a\u7528\u7684\u4ee3\u7801\u3002\u4f46\u771f\u6b63\u91cd\u8981\u7684\u90e8\u5206\u662f run \u51fd\u6570\uff0c\u6b63\u662f run \u51fd\u6570\u7684\u5b58\u5728\u4f7f\u5f97 HelloPass \u8868\u793a\u4e00\u4e2a pass\u3002 run \u51fd\u6570\u63a5\u6536\u4e24\u4e2a\u53c2\u6570\u3002\u7b2c\u4e00\u4e2a\u53c2\u6570 F \u662f\u4e00\u4e2a IR \u51fd\u6570\uff0c\u65b0\u7684 pass \u5c06\u5728\u8fd9\u4e2a\u51fd\u6570\u4e0a\u8fd0\u884c\u3002\u6ce8\u610f F \u662f\u901a\u8fc7\u4e00\u4e2a\u975e\u5e38\u91cf\u5f15\u7528\u4f20\u9012\u8fdb\u6765\u7684\uff0c\u8fd9\u8bf4\u660e\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u8fd9\u4e2a\u51fd\u6570\uff08\u4e5f\u5c31\u662f\u5bf9\u8fd9\u4e2a\u51fd\u6570\u4e2d\u5305\u542b\u7684 IR \u8fdb\u884c\u4fee\u6539\u548c\u53d8\u6362\uff09\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570 AM \u662f\u4e00\u4e2a pass \u7ba1\u7406\u5668\u7684\u5b9e\u4f8b\uff1b\u901a\u8fc7\u8fd9\u4e2a\u5b9e\u4f8b\uff0c\u65b0\u7684 pass \u53ef\u4ee5\u8bbf\u95ee\u5404\u79cd\u5206\u6790 pass \u5e76\u83b7\u5f97\u51fd\u6570\u7ea7\u522b\u7684\u5206\u6790\u4fe1\u606f\u3002 \u7531\u4e8e run \u51fd\u6570\u5c06 Function \u4f5c\u4e3a\u53c2\u6570\uff0c\u56e0\u6b64 HelloPass \u662f\u4e00\u4e2a \u51fd\u6570 pass \u3002Pass \u7ba1\u7406\u5668\u4f1a\u5b89\u6392\u51fd\u6570 pass \u4f9d\u6b21\u5728\u8f93\u5165\u7684 IR \u6a21\u5757\u4e2d\u5305\u542b\u7684\u6bcf\u4e2a\u51fd\u6570\u4e0a\u6267\u884c\u3002\u5f53 HelloPass \u5728\u67d0\u4e2a IR \u51fd\u6570\u4e0a\u6267\u884c\u65f6\uff0c\u5b83\u4f1a\u5c06\u51fd\u6570\u7684\u540d\u79f0\u5199\u5165\u6807\u51c6\u9519\u8bef\u6d41\u7136\u540e\u9000\u51fa\u3002 run \u51fd\u6570\u8fd4\u56de\u4e00\u4e2a PreservedAnalyses \u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u5305\u542b\u4e00\u4e9b\u4fe1\u606f\u7528\u4e8e\u6307\u793a\u5f53\u5f53\u524d\u7684 pass \u8fd0\u884c\u5b8c\u6bd5\u540e\uff0c\u5df2\u6709\u7684\u5206\u6790\u4fe1\u606f\u54ea\u4e9b\u662f\u53ef\u4ee5\u7ee7\u7eed\u4f7f\u7528\u7684\uff0c\u54ea\u4e9b\u662f\u4e0d\u80fd\u7ee7\u7eed\u4f7f\u7528\u7684\u3002 HelloPass \u7684 run \u51fd\u6570\u8fd4\u56de PreservedAnalyses::all() \u6765\u6307\u793a\u6240\u6709\u7684\u5206\u6790\u4fe1\u606f\u90fd\u7ee7\u7eed\u53ef\u7528\uff08\u8fd9\u662f\u56e0\u4e3a HelloPass \u5e76\u6ca1\u6709\u5bf9 IR \u8fdb\u884c\u4fee\u6539\uff0c\u4e5f\u5c31\u4e0d\u4f1a\u7834\u574f\u4efb\u4f55\u5df2\u6709\u7684\u5206\u6790\u4fe1\u606f\uff09\u3002 \u6ce8\u518c Pass \u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86\u5bf9\u8fd9\u4e2a\u7b80\u5355\u7684 pass \u7684\u5b9e\u73b0\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u544a\u8bc9 pass \u7ba1\u7406\u5668\u65b0\u7684 pass \u7684\u5b58\u5728\u3002\u6211\u4eec\u9700\u8981\u5411 pass \u7ba1\u7406\u5668 \u6ce8\u518c \u65b0\u7684 pass\u3002 \u7f16\u8f91 llvm/lib/Passes/PassRegistry.def \u5e76\u5411\u5176\u4e2d\u6dfb\u52a0\u5982\u4e0b\u5185\u5bb9\uff1a 1 FUNCTION_PASS ( \"hello\" , HelloPass ()) \u6ce8\u610f FUNCTION_PASS \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u5c31\u662f\u65b0\u7684 pass \u7684\u540d\u79f0\u3002 \u5411 llvm/lib/Passes/PassBuilder.cpp \u4e2d\u6dfb\u52a0\u5982\u4e0b\u7684 #include \uff1a 1 #include \"llvm/Transforms/Utils/Hello.h\" \u6ce8\u518c\u5de5\u4f5c\u5c31\u5b8c\u6210\u4e86\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5c06\u6784\u5efa\u5e76\u8fd0\u884c\u65b0\u7684 pass\u3002 \u6784\u5efa\u5e76\u8fd0\u884c \u8fdb\u5165\u6784\u5efa\u76ee\u5f55\u5e76\u6784\u5efa opt \u3002 opt \u662f\u4e00\u4e2a\u4e13\u95e8\u7528\u4e8e\u5728\u4e00\u6bb5 IR \u4e0a\u8fd0\u884c\u4e00\u4e2a\u6216\u4e00\u7cfb\u5217 pass \u7684\u5de5\u5177\u3002\u5f53 opt \u6784\u5efa\u5b8c\u6bd5\u540e\uff0c\u521b\u5efa\u4e00\u4e2a test.ll \u6587\u4ef6\u7528\u4e8e\u6d4b\u8bd5\uff1a 1 2 3 4 5 6 7 8 define i32 @foo () { %a = add i32 2 , 3 ret i32 %a } define void @bar () { ret void } \u7136\u540e\u4f7f\u7528 opt \u5de5\u5177\u8fd0\u884c\u65b0\u7684 pass\uff1a 1 build/bin/opt -disable-output test.ll -passes = hello -passes=hello \u7f16\u8bd1\u9009\u9879\u547d\u4ee4 opt \u8fd0\u884c HelloPass \u3002 opt \u5e94\u8be5\u8f93\u51fa\u5982\u4e0b\u5185\u5bb9\uff1a 1 2 foo bar \u606d\u559c\uff01\u60a8\u5b8c\u6210\u4e86\u60a8\u7684 LLVM pass\uff01 \u8bf7\u53c2\u9605 LLVM \u5b98\u65b9\u6587\u6863 \u4e86\u89e3\u5982\u4f55\u4ece\u6e90\u7801\u6784\u5efa LLVM\u3002 \u21a9 \u8fd9\u4e2a\u6ce8\u91ca \u7b80\u8981\u4ecb\u7ecd\u4e86 pass \u6846\u67b6\u4e2d\u6240\u4f7f\u7528\u7684\u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001\u673a\u5236\u3002 \u21a9 \u5bf9\u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001\u7684\u8be6\u7ec6\u4ecb\u7ecd\u548c\u8ba8\u8bba\u6587\u6863\u89c1 GuillaumeDua. Concept-based polymorphism in modern C++ \u3002 \u21a9","title":"llvm-pass-hello-world"},{"location":"llvm/pass/hello-world.zh/#\u7f16\u5199\u4e00\u4e2a-hello-world-pass","text":"\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u5e26\u9886\u60a8\u7f16\u5199\u5e76\u8fd0\u884c\u4e00\u4e2a\u975e\u5e38\u7b80\u5355\u7684 pass\uff0c\u8fd9\u4e2a pass \u53ef\u4ee5\u8f93\u51fa\u5728\u8f93\u5165\u7684 IR \u6a21\u5757\u4e2d\u5305\u542b\u7684\u6240\u6709\u51fd\u6570\u7684\u540d\u79f0\u3002","title":"\u7f16\u5199\u4e00\u4e2a Hello World Pass"},{"location":"llvm/pass/hello-world.zh/#\u8bbe\u7f6e\u6784\u5efa\u73af\u5883","text":"\u5047\u8bbe\u60a8\u5df2\u7ecf\u514b\u9686\u4e86 LLVM \u4ed3\u5e93 \u5e76\u5728 build \u76ee\u5f55\u4e0b\u8bbe\u7f6e\u597d\u4e86\u6784\u5efa\u6811 1 \uff0c\u5e76\u4e14\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u662f LLVM \u4ed3\u5e93\u7684\u6839\u76ee\u5f55\u3002\u672c\u8282\u4e2d\u6211\u4eec\u5c06\u5728\u6811\u5185\u6784\u5efa\u65b0\u7684 pass\uff0c\u8fd9\u610f\u5473\u7740\u65b0\u7684 pass \u7684\u6240\u6709\u4ee3\u7801\u90fd\u5305\u542b\u5728 LLVM \u4ed3\u5e93\u7684\u6e90\u4ee3\u7801\u76ee\u5f55\u4e0b\u3002 \u5728 llvm/include/llvm/Transforms/Utils/ \u4e0b\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a Hello.h \u7684\u6587\u4ef6\uff1a 1 touch llvm/include/llvm/Transforms/Utils/Hello.h \u5728 llvm/lib/Transforms/Utils/ \u4e0b\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a Hello.cpp \u7684\u6587\u4ef6\uff1a 1 touch llvm/lib/Transforms/Utils/Hello.cpp \u4fee\u6539 llvm/lib/Transforms/Utils/CMakeLists.txt \u5e76\u5c06 Hello.cpp \u52a0\u5165\u5230\u5bf9 add_llvm_component_library \u7684\u8c03\u7528\u4e2d\uff1a 1 2 3 4 5 add_llvm_component_library ( LLVMTransformUtils # Other files ... Hello.cpp # Other files and configurations ... ) \u8fd9\u4e00\u6b65\u662f\u4e3a\u4e86\u5c06 Hello.cpp \u6dfb\u52a0\u5230 LLVM \u7684\u6784\u5efa\u8fc7\u7a0b\u4e2d\u3002","title":"\u8bbe\u7f6e\u6784\u5efa\u73af\u5883"},{"location":"llvm/pass/hello-world.zh/#\u4ee3\u7801\u5b9e\u73b0","text":"\u5c06\u5982\u4e0b\u5185\u5bb9\u6dfb\u52a0\u5230 Hello.h \u4e2d\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #ifndef LLVM_TRANSFORMS_HELLO_H #define LLVM_TRANSFORMS_HELLO_H #include \"llvm/IR/PassManager.h\" namespace llvm { class HelloPass : public PassInfoMixin < HelloPass > { public : PreservedAnalyses run ( Function & F , FunctionAnalysisManager & AM ); }; } // namespace llvm #endif \u5c06\u5982\u4e0b\u5185\u5bb9\u6dfb\u52a0\u5230 Hello.cpp \u4e2d: 1 2 3 4 5 6 7 8 9 10 #include \"llvm/Transforms/Utils/Hello.h\" namespace llvm { PreservedAnalyses HelloPass::run ( Function & F , FunctionAnalysisManager & AM ) { errs () << F . getName () << \" \\n \" ; return PreservedAnalyses :: all (); } } // namespace llvm \u662f\u7684\uff01\u8fd9\u5c31\u662f\uff08\u51e0\u4e4e\uff09\u5168\u90e8\u4e3a\u4e86\u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684 pass \u60a8\u9700\u8981\u7f16\u5199\u7684\u4ee3\u7801\u3002\u8ba9\u6211\u4eec\u5c06\u8fd9\u6bb5\u4ee3\u7801\u8fdb\u4e00\u6b65\u5206\u89e3\u5e76\u770b\u770b\u5b83\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002 \u4e3a\u4e86\u4f7f\u7528 C++ \u521b\u5efa\u4e00\u4e2a pass\uff0c\u60a8\u9700\u8981\u7f16\u5199\u4e00\u4e2a\u5b9e\u73b0\u4e86 pass \u6240\u9700\u8981\u7684\u8f6f\u4ef6\u63a5\u53e3\u7684\u7c7b\u3002\u4f20\u7edf\u7684\u505a\u6cd5\u662f\u4ece\u67d0\u4e2a\u57fa\u7c7b\u6d3e\u751f\u51fa\u6765\u4e00\u4e2a\u7c7b\u5e76\u91cd\u5199\u67d0\u4e9b\u865a\u51fd\u6570\u4ee5\u5b9e\u73b0\u63a5\u53e3\uff0c\u4f46\u65b0\u7684 pass \u7ba1\u7406\u5668\u5e76\u6ca1\u6709\u91c7\u7528\u8fd9\u79cd\u65b9\u6cd5\uff0c\u800c\u662f\u91c7\u7528\u4e86\u4e00\u79cd\u88ab\u79f0\u4e3a \u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001 \uff08Concept-Based Polymorphism\uff09 2 3 \u7684\u65b9\u6cd5\u3002 \u53ea\u8981\u8fd9\u4e2a\u7c7b\u5305\u542b\u4e00\u4e2a\u540d\u4e3a run \u7684\u65b9\u6cd5\u4f7f\u4e4b\u53ef\u4ee5\u5728\u4e00\u6bb5 IR \u4e0a\u6267\u884c\uff0c\u90a3\u4e48\u8fd9\u4e2a\u7c7b\u5c31\u8868\u793a\u4e00\u4e2a pass\u3002 \u4e0d\u9700\u8981\u4ece\u67d0\u4e2a\u57fa\u7c7b\u6d3e\u751f\u51fa\u5b50\u7c7b\u6765\u8868\u793a\u4e00\u4e2a pass\u3002\u5728\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u7684 HelloPass \u7c7b\u7ee7\u627f\u81ea PassInfoMixin \u7c7b\uff0c\u8fd9\u4e2a\u57fa\u7c7b\u5411 HelloPass \u63d0\u4f9b\u7684\u63a5\u53e3\u4e2d\u53c8\u989d\u5916\u6dfb\u52a0\u4e86\u4e00\u4e9b\u901a\u7528\u7684\u4ee3\u7801\u3002\u4f46\u771f\u6b63\u91cd\u8981\u7684\u90e8\u5206\u662f run \u51fd\u6570\uff0c\u6b63\u662f run \u51fd\u6570\u7684\u5b58\u5728\u4f7f\u5f97 HelloPass \u8868\u793a\u4e00\u4e2a pass\u3002 run \u51fd\u6570\u63a5\u6536\u4e24\u4e2a\u53c2\u6570\u3002\u7b2c\u4e00\u4e2a\u53c2\u6570 F \u662f\u4e00\u4e2a IR \u51fd\u6570\uff0c\u65b0\u7684 pass \u5c06\u5728\u8fd9\u4e2a\u51fd\u6570\u4e0a\u8fd0\u884c\u3002\u6ce8\u610f F \u662f\u901a\u8fc7\u4e00\u4e2a\u975e\u5e38\u91cf\u5f15\u7528\u4f20\u9012\u8fdb\u6765\u7684\uff0c\u8fd9\u8bf4\u660e\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u8fd9\u4e2a\u51fd\u6570\uff08\u4e5f\u5c31\u662f\u5bf9\u8fd9\u4e2a\u51fd\u6570\u4e2d\u5305\u542b\u7684 IR \u8fdb\u884c\u4fee\u6539\u548c\u53d8\u6362\uff09\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570 AM \u662f\u4e00\u4e2a pass \u7ba1\u7406\u5668\u7684\u5b9e\u4f8b\uff1b\u901a\u8fc7\u8fd9\u4e2a\u5b9e\u4f8b\uff0c\u65b0\u7684 pass \u53ef\u4ee5\u8bbf\u95ee\u5404\u79cd\u5206\u6790 pass \u5e76\u83b7\u5f97\u51fd\u6570\u7ea7\u522b\u7684\u5206\u6790\u4fe1\u606f\u3002 \u7531\u4e8e run \u51fd\u6570\u5c06 Function \u4f5c\u4e3a\u53c2\u6570\uff0c\u56e0\u6b64 HelloPass \u662f\u4e00\u4e2a \u51fd\u6570 pass \u3002Pass \u7ba1\u7406\u5668\u4f1a\u5b89\u6392\u51fd\u6570 pass \u4f9d\u6b21\u5728\u8f93\u5165\u7684 IR \u6a21\u5757\u4e2d\u5305\u542b\u7684\u6bcf\u4e2a\u51fd\u6570\u4e0a\u6267\u884c\u3002\u5f53 HelloPass \u5728\u67d0\u4e2a IR \u51fd\u6570\u4e0a\u6267\u884c\u65f6\uff0c\u5b83\u4f1a\u5c06\u51fd\u6570\u7684\u540d\u79f0\u5199\u5165\u6807\u51c6\u9519\u8bef\u6d41\u7136\u540e\u9000\u51fa\u3002 run \u51fd\u6570\u8fd4\u56de\u4e00\u4e2a PreservedAnalyses \u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u5305\u542b\u4e00\u4e9b\u4fe1\u606f\u7528\u4e8e\u6307\u793a\u5f53\u5f53\u524d\u7684 pass \u8fd0\u884c\u5b8c\u6bd5\u540e\uff0c\u5df2\u6709\u7684\u5206\u6790\u4fe1\u606f\u54ea\u4e9b\u662f\u53ef\u4ee5\u7ee7\u7eed\u4f7f\u7528\u7684\uff0c\u54ea\u4e9b\u662f\u4e0d\u80fd\u7ee7\u7eed\u4f7f\u7528\u7684\u3002 HelloPass \u7684 run \u51fd\u6570\u8fd4\u56de PreservedAnalyses::all() \u6765\u6307\u793a\u6240\u6709\u7684\u5206\u6790\u4fe1\u606f\u90fd\u7ee7\u7eed\u53ef\u7528\uff08\u8fd9\u662f\u56e0\u4e3a HelloPass \u5e76\u6ca1\u6709\u5bf9 IR \u8fdb\u884c\u4fee\u6539\uff0c\u4e5f\u5c31\u4e0d\u4f1a\u7834\u574f\u4efb\u4f55\u5df2\u6709\u7684\u5206\u6790\u4fe1\u606f\uff09\u3002","title":"\u4ee3\u7801\u5b9e\u73b0"},{"location":"llvm/pass/hello-world.zh/#\u6ce8\u518c-pass","text":"\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86\u5bf9\u8fd9\u4e2a\u7b80\u5355\u7684 pass \u7684\u5b9e\u73b0\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u544a\u8bc9 pass \u7ba1\u7406\u5668\u65b0\u7684 pass \u7684\u5b58\u5728\u3002\u6211\u4eec\u9700\u8981\u5411 pass \u7ba1\u7406\u5668 \u6ce8\u518c \u65b0\u7684 pass\u3002 \u7f16\u8f91 llvm/lib/Passes/PassRegistry.def \u5e76\u5411\u5176\u4e2d\u6dfb\u52a0\u5982\u4e0b\u5185\u5bb9\uff1a 1 FUNCTION_PASS ( \"hello\" , HelloPass ()) \u6ce8\u610f FUNCTION_PASS \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u5c31\u662f\u65b0\u7684 pass \u7684\u540d\u79f0\u3002 \u5411 llvm/lib/Passes/PassBuilder.cpp \u4e2d\u6dfb\u52a0\u5982\u4e0b\u7684 #include \uff1a 1 #include \"llvm/Transforms/Utils/Hello.h\" \u6ce8\u518c\u5de5\u4f5c\u5c31\u5b8c\u6210\u4e86\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5c06\u6784\u5efa\u5e76\u8fd0\u884c\u65b0\u7684 pass\u3002","title":"\u6ce8\u518c Pass"},{"location":"llvm/pass/hello-world.zh/#\u6784\u5efa\u5e76\u8fd0\u884c","text":"\u8fdb\u5165\u6784\u5efa\u76ee\u5f55\u5e76\u6784\u5efa opt \u3002 opt \u662f\u4e00\u4e2a\u4e13\u95e8\u7528\u4e8e\u5728\u4e00\u6bb5 IR \u4e0a\u8fd0\u884c\u4e00\u4e2a\u6216\u4e00\u7cfb\u5217 pass \u7684\u5de5\u5177\u3002\u5f53 opt \u6784\u5efa\u5b8c\u6bd5\u540e\uff0c\u521b\u5efa\u4e00\u4e2a test.ll \u6587\u4ef6\u7528\u4e8e\u6d4b\u8bd5\uff1a 1 2 3 4 5 6 7 8 define i32 @foo () { %a = add i32 2 , 3 ret i32 %a } define void @bar () { ret void } \u7136\u540e\u4f7f\u7528 opt \u5de5\u5177\u8fd0\u884c\u65b0\u7684 pass\uff1a 1 build/bin/opt -disable-output test.ll -passes = hello -passes=hello \u7f16\u8bd1\u9009\u9879\u547d\u4ee4 opt \u8fd0\u884c HelloPass \u3002 opt \u5e94\u8be5\u8f93\u51fa\u5982\u4e0b\u5185\u5bb9\uff1a 1 2 foo bar \u606d\u559c\uff01\u60a8\u5b8c\u6210\u4e86\u60a8\u7684 LLVM pass\uff01 \u8bf7\u53c2\u9605 LLVM \u5b98\u65b9\u6587\u6863 \u4e86\u89e3\u5982\u4f55\u4ece\u6e90\u7801\u6784\u5efa LLVM\u3002 \u21a9 \u8fd9\u4e2a\u6ce8\u91ca \u7b80\u8981\u4ecb\u7ecd\u4e86 pass \u6846\u67b6\u4e2d\u6240\u4f7f\u7528\u7684\u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001\u673a\u5236\u3002 \u21a9 \u5bf9\u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001\u7684\u8be6\u7ec6\u4ecb\u7ecd\u548c\u8ba8\u8bba\u6587\u6863\u89c1 GuillaumeDua. Concept-based polymorphism in modern C++ \u3002 \u21a9","title":"\u6784\u5efa\u5e76\u8fd0\u884c"},{"location":"llvm/pass/index.zh/","text":"Pass LLVM Pass \u6846\u67b6\u662f LLVM \u7684\u4e00\u4e2a\u91cd\u8981\u7ec4\u6210\u90e8\u5206\uff0c\u7f16\u8bd1\u5668\u7684\u5927\u91cf\u6838\u5fc3\u4ee3\u7801\u90fd\u5305\u542b\u5728 LLVM pass \u4e2d\u3002LLVM pass \u53ef\u4ee5\u5bf9\u7a0b\u5e8f\u8fdb\u884c\u53d8\u6362\u548c\u4f18\u5316\uff0c\u53ef\u4ee5\u5bf9\u7a0b\u5e8f\u8fdb\u884c\u5206\u6790\u5e76\u8f93\u51fa\u53d8\u6362\u548c\u4f18\u5316\u6240\u5fc5\u987b\u7684\u5206\u6790\u4fe1\u606f\uff1b\u9664\u6b64\u4e4b\u5916\uff0cLLVM pass \u4e5f\u662f\u4e00\u79cd\u5bf9\u7f16\u8bd1\u5668\u4ee3\u7801\u8fdb\u884c\u7ec4\u7ec7\u7684\u5de5\u5177\u3002 \u4e00\u4e2a LLVM pass \u53ef\u4ee5\u88ab\u89c6\u4e3a\u4e00\u4e2a\u4ee5 LLVM IR \u4f5c\u4e3a\u8f93\u5165\u3001\u5e76\u4ea7\u751f\u67d0\u79cd\u4f9d\u8d56\u4e8e\u5177\u4f53 pass \u7684\u8f93\u51fa\u7684\u9ed1\u76d2\u3002\u6709\u4e24\u79cd\u4e0d\u540c\u7684 pass\uff1a \u53d8\u6362 pass \uff08Transformation Pass\uff09 \u4ee5\u53ca \u5206\u6790 pass \uff08Analysis Pass\uff09\u3002\u4e00\u4e2a\u53d8\u6362 pass \u901a\u5e38\u4f1a\u4fee\u6539\u8f93\u5165\u7684 IR \u5e76\u5c06\u8f6c\u6362\u540e\u7684 IR \u4f5c\u4e3a\u8f93\u51fa\u3002\u53e6\u5916\uff0c\u5c06\u8f93\u5165\u7684 LLVM IR \u4e0b\u964d\u5230 SelectionDAG \u4ee5\u53ca\u673a\u5668 IR \u7684 pass \u4e5f\u662f\u53d8\u6362 pass\u3002\u4e00\u4e2a\u5206\u6790 pass \u4e0d\u4f1a\u4fee\u6539\u8f93\u5165\u7684 IR\uff0c\u4f46\u5b83\u4f1a\u5bf9\u8f93\u5165\u7684 IR \u8fdb\u884c\u5206\u6790\u5e76\u4ea7\u751f\u63cf\u8ff0 IR \u7684\u67d0\u79cd\u5c5e\u6027\u7684\u4fe1\u606f\u3002\u53d8\u6362 pass \u901a\u5e38\u7528\u4e8e\u5b9e\u73b0\u7f16\u8bd1\u4f18\u5316\u3001\u7a0b\u5e8f\u53d8\u6362\u3001\u7a0b\u5e8f\u63d2\u6869\u7b49\u4efb\u52a1\u3002\u5206\u6790 pass \u901a\u5e38\u7528\u4e8e\u4e3a\u53d8\u6362 pass \u63d0\u4f9b\u5fc5\u8981\u7684\u4fe1\u606f\u3002 \u771f\u5b9e\u4e16\u754c\u7684\u7f16\u8bd1\u5668\u901a\u5e38\u4f1a\u4f9d\u8d56\u4e8e\u4e0a\u767e\u4e2a\u5728 IR \u4e0a\u4f9d\u6b21\u6267\u884c\u7684 pass \u6765\u5b8c\u6210\u7a0b\u5e8f\u4f18\u5316\u4ee5\u53ca\u4ee3\u7801\u751f\u6210\u5de5\u4f5c\u3002\u8fd9\u4e00\u4e2a\u7531\u591a\u4e2a pass \u7ec4\u6210\u7684\u3001\u6bcf\u4e2a pass \u4f9d\u6b21\u6267\u884c\u7684 pass \u5e8f\u5217\u4e00\u822c\u4e5f\u88ab\u79f0\u4e3a \u7ba1\u7ebf\uff08The Pipeline\uff09 \u3002\u9700\u8981\u6ce8\u610f\uff0c\u4e0d\u540c\u7684\u7f16\u8bd1\u914d\u7f6e\u901a\u5e38\u4f1a\u5f71\u54cd\u5230\u7ba1\u7ebf\u7684\u914d\u7f6e\uff0c\u4e5f\u5c31\u662f\u7ba1\u7ebf\u4e2d\u4f7f\u7528\u7684 pass \u96c6\u5408\u4ee5\u53ca pass \u6267\u884c\u7684\u5148\u540e\u987a\u5e8f\u3002 Pass \u53ef\u4ee5\u6709 \u4f9d\u8d56 \u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u53d8\u6362 pass \u5fc5\u987b\u5728\u5b83\u6240\u6709\u4f9d\u8d56\u7684\u5206\u6790 pass \u5b8c\u6210\u4e4b\u540e\u624d\u80fd\u6b63\u5e38\u8fd0\u884c\u3002\u53e6\u5916\uff0c\u67d0\u4e9b\u53d8\u6362 pass \u4f1a\u7834\u574f\u67d0\u4e9b\u5df2\u7ecf\u5f97\u5230\u5e76\u7f13\u5b58\u4e0b\u6765\u7684\u4ee3\u7801\u5206\u6790\u7ed3\u679c\u3002LLVM \u4f7f\u7528 pass \u7ba1\u7406\u5668 \uff08Pass Manager\uff09\u5bf9\u53ef\u7528\u7684 pass \u8fdb\u884c\u7ba1\u7406\u5e76\u5c06 pass \u7ba1\u7ebf\u8c03\u5ea6\u5230\u8f93\u5165\u7684 IR \u4e0a\u6267\u884c\u3002\u4f46\u662f\uff0c\u7531\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u76ee\u524d LLVM \u6709\u4e24\u7ec4\u4e0d\u540c\u7684 pass manager\uff1a\u65b0 pass \u7ba1\u7406\u5668\uff08New Pass Manager\uff09\u4ee5\u53ca\u65e7 pass manager\uff08Legacy Pass Manager\uff09\u3002\u672c wiki \u4e3b\u8981\u4ecb\u7ecd\u65b0 pass \u7ba1\u7406\u5668\uff1bLLVM \u793e\u533a\u4e5f\u6b63\u5728\u5c06\u4ee3\u7801\u8fc1\u79fb\u5230\u65b0 pass \u7ba1\u7406\u5668\u5e76\u5f03\u7528\u65e7 pass \u7ba1\u7406\u5668\u3002","title":"\u6982\u8ff0"},{"location":"llvm/pass/index.zh/#pass","text":"LLVM Pass \u6846\u67b6\u662f LLVM \u7684\u4e00\u4e2a\u91cd\u8981\u7ec4\u6210\u90e8\u5206\uff0c\u7f16\u8bd1\u5668\u7684\u5927\u91cf\u6838\u5fc3\u4ee3\u7801\u90fd\u5305\u542b\u5728 LLVM pass \u4e2d\u3002LLVM pass \u53ef\u4ee5\u5bf9\u7a0b\u5e8f\u8fdb\u884c\u53d8\u6362\u548c\u4f18\u5316\uff0c\u53ef\u4ee5\u5bf9\u7a0b\u5e8f\u8fdb\u884c\u5206\u6790\u5e76\u8f93\u51fa\u53d8\u6362\u548c\u4f18\u5316\u6240\u5fc5\u987b\u7684\u5206\u6790\u4fe1\u606f\uff1b\u9664\u6b64\u4e4b\u5916\uff0cLLVM pass \u4e5f\u662f\u4e00\u79cd\u5bf9\u7f16\u8bd1\u5668\u4ee3\u7801\u8fdb\u884c\u7ec4\u7ec7\u7684\u5de5\u5177\u3002 \u4e00\u4e2a LLVM pass \u53ef\u4ee5\u88ab\u89c6\u4e3a\u4e00\u4e2a\u4ee5 LLVM IR \u4f5c\u4e3a\u8f93\u5165\u3001\u5e76\u4ea7\u751f\u67d0\u79cd\u4f9d\u8d56\u4e8e\u5177\u4f53 pass \u7684\u8f93\u51fa\u7684\u9ed1\u76d2\u3002\u6709\u4e24\u79cd\u4e0d\u540c\u7684 pass\uff1a \u53d8\u6362 pass \uff08Transformation Pass\uff09 \u4ee5\u53ca \u5206\u6790 pass \uff08Analysis Pass\uff09\u3002\u4e00\u4e2a\u53d8\u6362 pass \u901a\u5e38\u4f1a\u4fee\u6539\u8f93\u5165\u7684 IR \u5e76\u5c06\u8f6c\u6362\u540e\u7684 IR \u4f5c\u4e3a\u8f93\u51fa\u3002\u53e6\u5916\uff0c\u5c06\u8f93\u5165\u7684 LLVM IR \u4e0b\u964d\u5230 SelectionDAG \u4ee5\u53ca\u673a\u5668 IR \u7684 pass \u4e5f\u662f\u53d8\u6362 pass\u3002\u4e00\u4e2a\u5206\u6790 pass \u4e0d\u4f1a\u4fee\u6539\u8f93\u5165\u7684 IR\uff0c\u4f46\u5b83\u4f1a\u5bf9\u8f93\u5165\u7684 IR \u8fdb\u884c\u5206\u6790\u5e76\u4ea7\u751f\u63cf\u8ff0 IR \u7684\u67d0\u79cd\u5c5e\u6027\u7684\u4fe1\u606f\u3002\u53d8\u6362 pass \u901a\u5e38\u7528\u4e8e\u5b9e\u73b0\u7f16\u8bd1\u4f18\u5316\u3001\u7a0b\u5e8f\u53d8\u6362\u3001\u7a0b\u5e8f\u63d2\u6869\u7b49\u4efb\u52a1\u3002\u5206\u6790 pass \u901a\u5e38\u7528\u4e8e\u4e3a\u53d8\u6362 pass \u63d0\u4f9b\u5fc5\u8981\u7684\u4fe1\u606f\u3002 \u771f\u5b9e\u4e16\u754c\u7684\u7f16\u8bd1\u5668\u901a\u5e38\u4f1a\u4f9d\u8d56\u4e8e\u4e0a\u767e\u4e2a\u5728 IR \u4e0a\u4f9d\u6b21\u6267\u884c\u7684 pass \u6765\u5b8c\u6210\u7a0b\u5e8f\u4f18\u5316\u4ee5\u53ca\u4ee3\u7801\u751f\u6210\u5de5\u4f5c\u3002\u8fd9\u4e00\u4e2a\u7531\u591a\u4e2a pass \u7ec4\u6210\u7684\u3001\u6bcf\u4e2a pass \u4f9d\u6b21\u6267\u884c\u7684 pass \u5e8f\u5217\u4e00\u822c\u4e5f\u88ab\u79f0\u4e3a \u7ba1\u7ebf\uff08The Pipeline\uff09 \u3002\u9700\u8981\u6ce8\u610f\uff0c\u4e0d\u540c\u7684\u7f16\u8bd1\u914d\u7f6e\u901a\u5e38\u4f1a\u5f71\u54cd\u5230\u7ba1\u7ebf\u7684\u914d\u7f6e\uff0c\u4e5f\u5c31\u662f\u7ba1\u7ebf\u4e2d\u4f7f\u7528\u7684 pass \u96c6\u5408\u4ee5\u53ca pass \u6267\u884c\u7684\u5148\u540e\u987a\u5e8f\u3002 Pass \u53ef\u4ee5\u6709 \u4f9d\u8d56 \u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u53d8\u6362 pass \u5fc5\u987b\u5728\u5b83\u6240\u6709\u4f9d\u8d56\u7684\u5206\u6790 pass \u5b8c\u6210\u4e4b\u540e\u624d\u80fd\u6b63\u5e38\u8fd0\u884c\u3002\u53e6\u5916\uff0c\u67d0\u4e9b\u53d8\u6362 pass \u4f1a\u7834\u574f\u67d0\u4e9b\u5df2\u7ecf\u5f97\u5230\u5e76\u7f13\u5b58\u4e0b\u6765\u7684\u4ee3\u7801\u5206\u6790\u7ed3\u679c\u3002LLVM \u4f7f\u7528 pass \u7ba1\u7406\u5668 \uff08Pass Manager\uff09\u5bf9\u53ef\u7528\u7684 pass \u8fdb\u884c\u7ba1\u7406\u5e76\u5c06 pass \u7ba1\u7ebf\u8c03\u5ea6\u5230\u8f93\u5165\u7684 IR \u4e0a\u6267\u884c\u3002\u4f46\u662f\uff0c\u7531\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u76ee\u524d LLVM \u6709\u4e24\u7ec4\u4e0d\u540c\u7684 pass manager\uff1a\u65b0 pass \u7ba1\u7406\u5668\uff08New Pass Manager\uff09\u4ee5\u53ca\u65e7 pass manager\uff08Legacy Pass Manager\uff09\u3002\u672c wiki \u4e3b\u8981\u4ecb\u7ecd\u65b0 pass \u7ba1\u7406\u5668\uff1bLLVM \u793e\u533a\u4e5f\u6b63\u5728\u5c06\u4ee3\u7801\u8fc1\u79fb\u5230\u65b0 pass \u7ba1\u7406\u5668\u5e76\u5f03\u7528\u65e7 pass \u7ba1\u7406\u5668\u3002","title":"Pass"},{"location":"mlir/mlir/","text":"Multi-Level Intermediate Representation The MLIR project is developing rapidly, and the situation may change at any time, please pay attention to the writing time of the page when reading . The MLIR project is a novel approach to building reusable and extensible compiler infrastructure. MLIR aims to address software fragmentation, improve compilation for heterogeneous hardware, significantly reduce the cost of building domain-specific compilers, and aid in connecting existing compilers together. In simple terms, MLIR is a general framework for writing various types of analyzes and transforms in compilers and the intermediate representations they require. It provides a series of facilities for compiler developers to define new IRs and use existing IRs conveniently and quickly. Developers can easily mix various IRs, freely converting between them, and make different levels of analysis to finally generate the object code. The MLIR project also contains some pre-written \"IRs\" ready for immediate use. You can start to understand these existing \"IRs\" and learn how to build your own \"IR\" from the basic concepts and building blocks of MLIR: dialect . Introduction to this section of the wiki This section of the wiki aims to: Aids in the development of MLIR itself Assist in the development of new dialects based on MLIR Assist in the use of MLIR's existing dialects and passes Related Links Official Documentation CodeGen Dialect Overview A post introducing the descent path of each dialect in MLIR. Although it is a bit old and some dialects have been dismantled, the classification is worth pondering. A picture is worth a thousand words , and you should definitely read the pictures even if you are too busy reading the words. The author classifies MLIR with two dimensions: data and algorithm. From Tensor -> Buffer, the data gradually changes from abstract tensor to memory. From Structure -> Payload, algorithms from high-level, structured descriptions to low-level, imperative codes The author also shared the concerns of each dialect","title":"mlir-overview"},{"location":"mlir/mlir/#multi-level-intermediate-representation","text":"The MLIR project is developing rapidly, and the situation may change at any time, please pay attention to the writing time of the page when reading . The MLIR project is a novel approach to building reusable and extensible compiler infrastructure. MLIR aims to address software fragmentation, improve compilation for heterogeneous hardware, significantly reduce the cost of building domain-specific compilers, and aid in connecting existing compilers together. In simple terms, MLIR is a general framework for writing various types of analyzes and transforms in compilers and the intermediate representations they require. It provides a series of facilities for compiler developers to define new IRs and use existing IRs conveniently and quickly. Developers can easily mix various IRs, freely converting between them, and make different levels of analysis to finally generate the object code. The MLIR project also contains some pre-written \"IRs\" ready for immediate use. You can start to understand these existing \"IRs\" and learn how to build your own \"IR\" from the basic concepts and building blocks of MLIR: dialect .","title":"Multi-Level Intermediate Representation"},{"location":"mlir/mlir/#introduction-to-this-section-of-the-wiki","text":"This section of the wiki aims to: Aids in the development of MLIR itself Assist in the development of new dialects based on MLIR Assist in the use of MLIR's existing dialects and passes","title":"Introduction to this section of the wiki"},{"location":"mlir/mlir/#related-links","text":"Official Documentation CodeGen Dialect Overview A post introducing the descent path of each dialect in MLIR. Although it is a bit old and some dialects have been dismantled, the classification is worth pondering. A picture is worth a thousand words , and you should definitely read the pictures even if you are too busy reading the words. The author classifies MLIR with two dimensions: data and algorithm. From Tensor -> Buffer, the data gradually changes from abstract tensor to memory. From Structure -> Payload, algorithms from high-level, structured descriptions to low-level, imperative codes The author also shared the concerns of each dialect","title":"Related Links"},{"location":"mlir/mlir.zh/","text":"Multi-Level Intermediate Representation MLIR \u9879\u76ee\u6b63\u5728\u6781\u901f\u53d1\u5c55\u4e2d\uff0c\u60c5\u51b5\u968f\u65f6\u6709\u53ef\u80fd\u53d1\u751f\u53d8\u5316\uff0c\u8bf7\u5728\u9605\u8bfb\u65f6\u5173\u6ce8\u9875\u9762\u7684\u4e66\u5199\u65f6\u95f4 . MLIR \u9879\u76ee\u662f\u4e00\u6b21\u5168\u65b0\u7684\uff0c\u6784\u5efa\u53ef\u91cd\u7528\u3001\u53ef\u6269\u5c55\u7684\u7f16\u8bd1\u5668\u57fa\u7840\u8bbe\u65bd\u7684\u5c1d\u8bd5\u3002\u5b83\u65e8\u5728\u89e3\u51b3\u8f6f\u4ef6\u788e\u7247\u5316\u95ee\u9898\uff0c\u6539\u8fdb\u5f02\u6784\u786c\u4ef6\u4e0a\u7684\u7f16\u8bd1\uff0c\u51cf\u5c11\u9886\u57df\u7279\u5b9a\u7f16\u8bd1\u5668\u7684\u5f00\u53d1\u4ee3\u4ef7\uff0c\u4ee5\u53ca\u8fde\u63a5\u73b0\u6709\u7684\u7f16\u8bd1\u5668\u8bbe\u65bd\u3002 \u7b80\u5355\u6765\u8bf4\uff0cMLIR \u662f\u7528\u4e8e\u7f16\u5199\u7f16\u8bd1\u5668\u4e2d\u5404\u7c7b\u5206\u6790\u4e0e\u53d8\u6362\u53ca\u5176\u6240\u9700\u7684\u4e2d\u95f4\u8868\u793a\u7684\u901a\u7528\u6846\u67b6\u3002\u5176\u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u8bbe\u65bd\u4ee5\u4f9b\u7f16\u8bd1\u5668\u5f00\u53d1\u8005\u65b9\u4fbf\u5feb\u901f\u5730\u5b9a\u4e49\u65b0\u7684 IR \u4e0e\u4f7f\u7528\u73b0\u6709\u7684\u5404\u7c7b IR. \u5f00\u53d1\u8005\u53ef\u4ee5\u65b9\u4fbf\u5730\u6df7\u7528\u5404\u7c7b IR, \u5728\u5b83\u4eec\u4e4b\u4e2d\u4e0e\u4e4b\u95f4\u81ea\u7531\u8f6c\u6362\uff0c\u8fdb\u884c\u4e0d\u540c\u5c42\u6b21\u7684\u5206\u6790\uff0c\u6700\u7ec8\u751f\u6210\u76ee\u6807\u4ee3\u7801\u3002 MLIR \u9879\u76ee\u4e2d\u8fd8\u5305\u542b\u4e86\u4e00\u4e9b\u5df2\u7ecf\u7f16\u5199\u597d\u7684 \"IR\", \u53ef\u4f9b\u76f4\u63a5\u4f7f\u7528\u3002\u53ef\u4ee5\u4ece MLIR \u7684\u57fa\u672c\u6982\u5ff5\u4e0e\u7ec4\u6210\u6a21\u5757\uff1a \u65b9\u8a00 \u5f00\u59cb\u4e86\u89e3\u8fd9\u4e9b\u73b0\u6709\u7684 \"IR\" \u4e0e\u5b66\u4e60\u5982\u4f55\u6784\u5efa\u81ea\u5df1\u7684 \"IR\". \u672c Wiki \u7b80\u4ecb \u672c Wiki \u65e8\u5728\uff1a \u8f85\u52a9 MLIR \u672c\u8eab\u7684\u5f00\u53d1 \u8f85\u52a9\u57fa\u4e8e MLIR \u7684\u65b0\u65b9\u8a00\u7684\u5f00\u53d1 \u8f85\u52a9\u5bf9 MLIR \u81ea\u5e26\u65b9\u8a00\u4e0e pass \u7684\u4f7f\u7528 \u76f8\u5173\u94fe\u63a5 \u5b98\u65b9\u6587\u6863 CodeGen Dialect Overview \u4e00\u7bc7\u4ecb\u7ecd MLIR \u4e2d\u5404\u4e2a\u65b9\u8a00\u4e0b\u964d\u8def\u5f84\u7684\u5e16\u5b50\uff0c\u867d\u7136\u8001\u4e86\u4e00\u70b9\uff0c\u6709\u4e9b\u65b9\u8a00\u5df2\u7ecf\u88ab\u62c6\u4e86\uff0c\u4f46\u662f\u5176\u4e2d\u7684\u5206\u7c7b\u503c\u5f97\u6df1\u601d\u3002\u5176\u4e2d\u7684\u56fe\u7247\u66f4\u662f \u4e00\u56fe\u80dc\u5343\u8a00\uff0c\u4e0d\u770b\u5b57\u4e5f\u5f97\u770b\u56fe\u3002 \u4f5c\u8005\u5c06 MLIR \u6309\u7167\u6570\u636e - \u7b97\u6cd5\u4e24\u4e2a\u7ef4\u5ea6\u5206\u7c7b\u3002\u6570\u636e\u4ece Tensor -> Buffer, \u9010\u6e10\u4ece\u62bd\u8c61\u7684\u5f20\u91cf\u5177\u4f53\u5230\u5185\u5b58\u3002\u7b97\u6cd5\u4ece Structure -> Payload, \u4e5f\u5c31\u662f\u4ece\u9ad8\u5c42\u7684\uff0c\u7ed3\u6784\u5316\u7684\u63cf\u8ff0\u5230\u5e95\u5c42\u7684\uff0c\u547d\u4ee4\u5f0f\u7684\u4e1c\u897f \u4f5c\u8005\u8fd8\u5206\u4eab\u4e86\u5404\u4e2a\u65b9\u8a00\u7684\u5173\u6ce8\u70b9 \u5982\u4f55\u8bc4\u4ef7 MLIR \u9879\u76ee\u4e2d Linalg Dialect \u7684\u8bbe\u8ba1\u601d\u60f3\uff1f - mackler \u7684\u56de\u7b54 - \u77e5\u4e4e \u5bf9 MLIR \u7684\u6bd4\u8f83 \"\u5c16\u9510\" \u7684\u610f\u89c1 \u5176\u5bf9\u7f16\u8bd1\u5668\u4f18\u5316\u7684\u5206\u7c7b\u4ee4\u4eba\u773c\u524d\u4e00\u4eae\uff1aauto-tiling/auto-tensorize/auto-schedule \u4e00\u4e9b\u5173\u6ce8 MLIR \u7684\u4e2d\u6587\u4f7f\u7528\u8005\uff0c\u53ef\u4ee5\u8ddf\u7740 timeline \u770b\u770b hunterzju : \u4e3b\u8981\u5173\u6ce8 CIRCT \u9879\u76ee, \u5199\u4e86\u4e00\u4e9b MLIR Toy Tutorial \u7684\u7b14\u8bb0\u548c\u6587\u6863\u7684\u7ffb\u8bd1 mackler : \u4e3b\u8981\u504f\u5411 MLIR \u5728 AI \u9886\u57df\u7684\u5de5\u4f5c\uff0c\u867d\u7136 ta \u53ef\u80fd\u66f4\u591a\u7684\u662f\u5173\u6ce8\u5e7f\u4e49\u7684\u8ba1\u7b97\u673a\u4f53\u7cfb\u548c\u4f18\u5316 \u6cd5\u65af\u7279\u8c6a\u65af : Buddy-mlir \u9879\u76ee\u7684 \"\u4e3b\u6301\u4eba\", \u57fa\u672c\u4e0a\u4e3b\u9875\u90fd\u662f\u5173\u4e8e MLIR \u7684\u4fe1\u606f MLIR \u4e2d\u56fd\u793e\u533a : \u987e\u540d\u601d\u4e49","title":"mlir-overview"},{"location":"mlir/mlir.zh/#multi-level-intermediate-representation","text":"MLIR \u9879\u76ee\u6b63\u5728\u6781\u901f\u53d1\u5c55\u4e2d\uff0c\u60c5\u51b5\u968f\u65f6\u6709\u53ef\u80fd\u53d1\u751f\u53d8\u5316\uff0c\u8bf7\u5728\u9605\u8bfb\u65f6\u5173\u6ce8\u9875\u9762\u7684\u4e66\u5199\u65f6\u95f4 . MLIR \u9879\u76ee\u662f\u4e00\u6b21\u5168\u65b0\u7684\uff0c\u6784\u5efa\u53ef\u91cd\u7528\u3001\u53ef\u6269\u5c55\u7684\u7f16\u8bd1\u5668\u57fa\u7840\u8bbe\u65bd\u7684\u5c1d\u8bd5\u3002\u5b83\u65e8\u5728\u89e3\u51b3\u8f6f\u4ef6\u788e\u7247\u5316\u95ee\u9898\uff0c\u6539\u8fdb\u5f02\u6784\u786c\u4ef6\u4e0a\u7684\u7f16\u8bd1\uff0c\u51cf\u5c11\u9886\u57df\u7279\u5b9a\u7f16\u8bd1\u5668\u7684\u5f00\u53d1\u4ee3\u4ef7\uff0c\u4ee5\u53ca\u8fde\u63a5\u73b0\u6709\u7684\u7f16\u8bd1\u5668\u8bbe\u65bd\u3002 \u7b80\u5355\u6765\u8bf4\uff0cMLIR \u662f\u7528\u4e8e\u7f16\u5199\u7f16\u8bd1\u5668\u4e2d\u5404\u7c7b\u5206\u6790\u4e0e\u53d8\u6362\u53ca\u5176\u6240\u9700\u7684\u4e2d\u95f4\u8868\u793a\u7684\u901a\u7528\u6846\u67b6\u3002\u5176\u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u8bbe\u65bd\u4ee5\u4f9b\u7f16\u8bd1\u5668\u5f00\u53d1\u8005\u65b9\u4fbf\u5feb\u901f\u5730\u5b9a\u4e49\u65b0\u7684 IR \u4e0e\u4f7f\u7528\u73b0\u6709\u7684\u5404\u7c7b IR. \u5f00\u53d1\u8005\u53ef\u4ee5\u65b9\u4fbf\u5730\u6df7\u7528\u5404\u7c7b IR, \u5728\u5b83\u4eec\u4e4b\u4e2d\u4e0e\u4e4b\u95f4\u81ea\u7531\u8f6c\u6362\uff0c\u8fdb\u884c\u4e0d\u540c\u5c42\u6b21\u7684\u5206\u6790\uff0c\u6700\u7ec8\u751f\u6210\u76ee\u6807\u4ee3\u7801\u3002 MLIR \u9879\u76ee\u4e2d\u8fd8\u5305\u542b\u4e86\u4e00\u4e9b\u5df2\u7ecf\u7f16\u5199\u597d\u7684 \"IR\", \u53ef\u4f9b\u76f4\u63a5\u4f7f\u7528\u3002\u53ef\u4ee5\u4ece MLIR \u7684\u57fa\u672c\u6982\u5ff5\u4e0e\u7ec4\u6210\u6a21\u5757\uff1a \u65b9\u8a00 \u5f00\u59cb\u4e86\u89e3\u8fd9\u4e9b\u73b0\u6709\u7684 \"IR\" \u4e0e\u5b66\u4e60\u5982\u4f55\u6784\u5efa\u81ea\u5df1\u7684 \"IR\".","title":"Multi-Level Intermediate Representation"},{"location":"mlir/mlir.zh/#\u672c-wiki-\u7b80\u4ecb","text":"\u672c Wiki \u65e8\u5728\uff1a \u8f85\u52a9 MLIR \u672c\u8eab\u7684\u5f00\u53d1 \u8f85\u52a9\u57fa\u4e8e MLIR \u7684\u65b0\u65b9\u8a00\u7684\u5f00\u53d1 \u8f85\u52a9\u5bf9 MLIR \u81ea\u5e26\u65b9\u8a00\u4e0e pass \u7684\u4f7f\u7528","title":"\u672c Wiki \u7b80\u4ecb"},{"location":"mlir/mlir.zh/#\u76f8\u5173\u94fe\u63a5","text":"\u5b98\u65b9\u6587\u6863 CodeGen Dialect Overview \u4e00\u7bc7\u4ecb\u7ecd MLIR \u4e2d\u5404\u4e2a\u65b9\u8a00\u4e0b\u964d\u8def\u5f84\u7684\u5e16\u5b50\uff0c\u867d\u7136\u8001\u4e86\u4e00\u70b9\uff0c\u6709\u4e9b\u65b9\u8a00\u5df2\u7ecf\u88ab\u62c6\u4e86\uff0c\u4f46\u662f\u5176\u4e2d\u7684\u5206\u7c7b\u503c\u5f97\u6df1\u601d\u3002\u5176\u4e2d\u7684\u56fe\u7247\u66f4\u662f \u4e00\u56fe\u80dc\u5343\u8a00\uff0c\u4e0d\u770b\u5b57\u4e5f\u5f97\u770b\u56fe\u3002 \u4f5c\u8005\u5c06 MLIR \u6309\u7167\u6570\u636e - \u7b97\u6cd5\u4e24\u4e2a\u7ef4\u5ea6\u5206\u7c7b\u3002\u6570\u636e\u4ece Tensor -> Buffer, \u9010\u6e10\u4ece\u62bd\u8c61\u7684\u5f20\u91cf\u5177\u4f53\u5230\u5185\u5b58\u3002\u7b97\u6cd5\u4ece Structure -> Payload, \u4e5f\u5c31\u662f\u4ece\u9ad8\u5c42\u7684\uff0c\u7ed3\u6784\u5316\u7684\u63cf\u8ff0\u5230\u5e95\u5c42\u7684\uff0c\u547d\u4ee4\u5f0f\u7684\u4e1c\u897f \u4f5c\u8005\u8fd8\u5206\u4eab\u4e86\u5404\u4e2a\u65b9\u8a00\u7684\u5173\u6ce8\u70b9 \u5982\u4f55\u8bc4\u4ef7 MLIR \u9879\u76ee\u4e2d Linalg Dialect \u7684\u8bbe\u8ba1\u601d\u60f3\uff1f - mackler \u7684\u56de\u7b54 - \u77e5\u4e4e \u5bf9 MLIR \u7684\u6bd4\u8f83 \"\u5c16\u9510\" \u7684\u610f\u89c1 \u5176\u5bf9\u7f16\u8bd1\u5668\u4f18\u5316\u7684\u5206\u7c7b\u4ee4\u4eba\u773c\u524d\u4e00\u4eae\uff1aauto-tiling/auto-tensorize/auto-schedule \u4e00\u4e9b\u5173\u6ce8 MLIR \u7684\u4e2d\u6587\u4f7f\u7528\u8005\uff0c\u53ef\u4ee5\u8ddf\u7740 timeline \u770b\u770b hunterzju : \u4e3b\u8981\u5173\u6ce8 CIRCT \u9879\u76ee, \u5199\u4e86\u4e00\u4e9b MLIR Toy Tutorial \u7684\u7b14\u8bb0\u548c\u6587\u6863\u7684\u7ffb\u8bd1 mackler : \u4e3b\u8981\u504f\u5411 MLIR \u5728 AI \u9886\u57df\u7684\u5de5\u4f5c\uff0c\u867d\u7136 ta \u53ef\u80fd\u66f4\u591a\u7684\u662f\u5173\u6ce8\u5e7f\u4e49\u7684\u8ba1\u7b97\u673a\u4f53\u7cfb\u548c\u4f18\u5316 \u6cd5\u65af\u7279\u8c6a\u65af : Buddy-mlir \u9879\u76ee\u7684 \"\u4e3b\u6301\u4eba\", \u57fa\u672c\u4e0a\u4e3b\u9875\u90fd\u662f\u5173\u4e8e MLIR \u7684\u4fe1\u606f MLIR \u4e2d\u56fd\u793e\u533a : \u987e\u540d\u601d\u4e49","title":"\u76f8\u5173\u94fe\u63a5"},{"location":"mlir/basic/dialect/","text":"Dialect Dialects are a crucial part of MLIR. It can be said that MLIR without various dialects is like a language without a standard library, and will not have any practical use. If the MLIR framework itself is compared to the foundation, then the various dialects built on top of MLIR are buildings with different styles. Data and information flow within and between buildings, forming a city with ducks in a row. As far as learning is concerned, the learning of dialects can be divided into two parts: Learn how to construct your dialect Learn the meaning of various operations in the built-in dialect The former is like learning to build a building, and the latter is like visiting a \"model house\". Basic Concepts A dialect can completely define anything that belongs to it, like new operations, properties, and types. New operations in the dialect can define their exclusive syntax format and output format. It is very reasonable and normal to see operations with unique text forms in the operations of different dialects. Things from different dialects can coexist harmoniously in the same module/function. At the same time, dialect writers can provide passes that convert operations in other dialects to their dialects, and can also write passes that convert operations in their dialects to other dialects. These conversions can be completed, converting all operations in A dialect to B; or step by step, only converting certain operations in A to B, and converting the rest to C. Consider the following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Define a function using the func operator in the func dialect // Using a custom syntax, the textual form of the operation looks similar to a function definition in a normal language func. func @main() { // use constant operations in the arith dialect // using the basic syntax %lb = arith.constant 0 : index %ub = arith. constant 5 : index %step = arith. constant 1 : index %sum_0 = arith.constant 0.0 : f32 %t = arith.constant 5.0 : f32 // use the for operator in the scf dialect // It has custom syntax and can be written to look like \"trailing closures\" in other languages // takes a \"function\" as its own parameter %sum = scf.for %iv = %lb to %ub step %step iter_args(%sum_iter = %sum_0) -> (f32) { %1 = arith.addf %sum_iter , %t : f32 scf. yield %1 : f32 } // use the print operation in the vector dialect vector.print %sum : f32 return } After this example is written, various conversion passes can be used to gradually or directly convert operations in various dialects into operations in LLVM dialects, and then translate them into LLVM IR to obtain executable files. It can be seen that each dialect is very free. So to read MLIR code text, it is not enough to only be familiar with the MLIR core framework. You must refer to the documentation of the dialect you want to use, and be familiar with the meaning and syntax of each operation in them, to read efficiently. All dialects are equal, but some dialects are more equal, and they are the dialects that are shipped in the MLIR project repository. These dialects are widely used. Before learning other dialects, it is recommended to read the documentation of [some of the most commonly used built-in dialects] (#Common Dialects). Build a New Dialect This part can refer to the official Toy Tutorial . Learn the Built-in Dialect Currently, the MLIR official repository contains some built-in dialects and conversions between them. These dialects can be regarded as MLIR's \"standard library\". Depending on the degree of versatility and focus, they can be classified as follows: Due to the rapid development of MLIR, the list of dialects below will not be guaranteed to be complete. For a complete list, please refer to the official documentation . Common Dialects The following are very generic dialects. Any other built-in dialects will more or less use the operations in the above dialects. Learning them is an important part of understanding existing dialects: builtin : built-in dialect, contains some facilities that may be used in all dialects, and should theoretically be kept very small. It also contains type definitions for the basic types of each built-in dialect func : function dialect, used to express function definition/function call arith : arithmetic dialect, including various basic arithmetic operations affine : affine transformation dialect, which is a high-level description of index space/address space mapping memref : memory area dialect, which is a high-level abstraction of memory and various operations on it There are also generic dialects, but may relatively be used less than the dialects above: cf : Express unstructured control flow, such as goto and the like scf : express structured control flow, such as for/while/if math : common numerical operation functions complex : commonly used complex numerical operation functions index : platform-independent operations on indexed types, perhaps comparable to \"high-level pointer arithmetic\" LLVM Dialects Then there is a very specific dialect: llvm , the LLVM dialect. It's a dialect that maintains a one-to-one mapping with concepts in LLVM IR. It acts as the \"lowest level\" in most dialect-lowering paths. Other dialects gradually lower to the LLVM dialect, and then translated into LLVM IR, and then have various optimizations of LLVM and the ability to translate to all backends of LLVM. If you don't understand an operation in a dialect, while it provides a lowering pass, you can read the lowering pass to understand what it means. The whole process is similar to learning C from a C compiler. In this process, the LLVM dialect acts like an assembly language. Domain-Specific Dialects There are some domain-specific dialects, most of which are designed to effectively express information highly related to a certain domain at a very high level of abstraction. So an understanding of specific domains will play a great role in understanding the following dialects. They are: vector : dialect for auto-vectorization, designed to express information about various SIMD operations in a platform-independent manner linalg : high-level abstraction related to deep learning model representation spirv : support for SPIR-V , a dialect for expressing graphics concepts such as shaders omp : support for OpenMP for expressing automatic multithreading related concepts gpu : GPU dialect designed to express platform-independently operations on the GPU async : dialect for expressing asynchronous operations pdl , pdl_interp : MLIR dialect for MLIR transformation, making it possible to use MLIR pass to analyze MLIR pass Platform-dependent Dialects Among the above dialects, there are also some dialects for platform-specific optimization. They are designed to describe the characteristics of a certain CPU or instruction set in detail and guide the optimization. Their names are relatively intuitive: GPU: amdgpu nvgpu nvvm : NVVM IR for CUDA ARM: arm_neon arm_sve Intel: amx : The Intel Advanced Matrix Extensions x86vector","title":"mlir-dialect"},{"location":"mlir/basic/dialect/#dialect","text":"Dialects are a crucial part of MLIR. It can be said that MLIR without various dialects is like a language without a standard library, and will not have any practical use. If the MLIR framework itself is compared to the foundation, then the various dialects built on top of MLIR are buildings with different styles. Data and information flow within and between buildings, forming a city with ducks in a row. As far as learning is concerned, the learning of dialects can be divided into two parts: Learn how to construct your dialect Learn the meaning of various operations in the built-in dialect The former is like learning to build a building, and the latter is like visiting a \"model house\".","title":"Dialect"},{"location":"mlir/basic/dialect/#basic-concepts","text":"A dialect can completely define anything that belongs to it, like new operations, properties, and types. New operations in the dialect can define their exclusive syntax format and output format. It is very reasonable and normal to see operations with unique text forms in the operations of different dialects. Things from different dialects can coexist harmoniously in the same module/function. At the same time, dialect writers can provide passes that convert operations in other dialects to their dialects, and can also write passes that convert operations in their dialects to other dialects. These conversions can be completed, converting all operations in A dialect to B; or step by step, only converting certain operations in A to B, and converting the rest to C. Consider the following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Define a function using the func operator in the func dialect // Using a custom syntax, the textual form of the operation looks similar to a function definition in a normal language func. func @main() { // use constant operations in the arith dialect // using the basic syntax %lb = arith.constant 0 : index %ub = arith. constant 5 : index %step = arith. constant 1 : index %sum_0 = arith.constant 0.0 : f32 %t = arith.constant 5.0 : f32 // use the for operator in the scf dialect // It has custom syntax and can be written to look like \"trailing closures\" in other languages // takes a \"function\" as its own parameter %sum = scf.for %iv = %lb to %ub step %step iter_args(%sum_iter = %sum_0) -> (f32) { %1 = arith.addf %sum_iter , %t : f32 scf. yield %1 : f32 } // use the print operation in the vector dialect vector.print %sum : f32 return } After this example is written, various conversion passes can be used to gradually or directly convert operations in various dialects into operations in LLVM dialects, and then translate them into LLVM IR to obtain executable files. It can be seen that each dialect is very free. So to read MLIR code text, it is not enough to only be familiar with the MLIR core framework. You must refer to the documentation of the dialect you want to use, and be familiar with the meaning and syntax of each operation in them, to read efficiently. All dialects are equal, but some dialects are more equal, and they are the dialects that are shipped in the MLIR project repository. These dialects are widely used. Before learning other dialects, it is recommended to read the documentation of [some of the most commonly used built-in dialects] (#Common Dialects).","title":"Basic Concepts"},{"location":"mlir/basic/dialect/#build-a-new-dialect","text":"This part can refer to the official Toy Tutorial .","title":"Build a New Dialect"},{"location":"mlir/basic/dialect/#learn-the-built-in-dialect","text":"Currently, the MLIR official repository contains some built-in dialects and conversions between them. These dialects can be regarded as MLIR's \"standard library\". Depending on the degree of versatility and focus, they can be classified as follows: Due to the rapid development of MLIR, the list of dialects below will not be guaranteed to be complete. For a complete list, please refer to the official documentation .","title":"Learn the Built-in Dialect"},{"location":"mlir/basic/dialect/#common-dialects","text":"The following are very generic dialects. Any other built-in dialects will more or less use the operations in the above dialects. Learning them is an important part of understanding existing dialects: builtin : built-in dialect, contains some facilities that may be used in all dialects, and should theoretically be kept very small. It also contains type definitions for the basic types of each built-in dialect func : function dialect, used to express function definition/function call arith : arithmetic dialect, including various basic arithmetic operations affine : affine transformation dialect, which is a high-level description of index space/address space mapping memref : memory area dialect, which is a high-level abstraction of memory and various operations on it There are also generic dialects, but may relatively be used less than the dialects above: cf : Express unstructured control flow, such as goto and the like scf : express structured control flow, such as for/while/if math : common numerical operation functions complex : commonly used complex numerical operation functions index : platform-independent operations on indexed types, perhaps comparable to \"high-level pointer arithmetic\"","title":"Common Dialects"},{"location":"mlir/basic/dialect/#llvm-dialects","text":"Then there is a very specific dialect: llvm , the LLVM dialect. It's a dialect that maintains a one-to-one mapping with concepts in LLVM IR. It acts as the \"lowest level\" in most dialect-lowering paths. Other dialects gradually lower to the LLVM dialect, and then translated into LLVM IR, and then have various optimizations of LLVM and the ability to translate to all backends of LLVM. If you don't understand an operation in a dialect, while it provides a lowering pass, you can read the lowering pass to understand what it means. The whole process is similar to learning C from a C compiler. In this process, the LLVM dialect acts like an assembly language.","title":"LLVM Dialects"},{"location":"mlir/basic/dialect/#domain-specific-dialects","text":"There are some domain-specific dialects, most of which are designed to effectively express information highly related to a certain domain at a very high level of abstraction. So an understanding of specific domains will play a great role in understanding the following dialects. They are: vector : dialect for auto-vectorization, designed to express information about various SIMD operations in a platform-independent manner linalg : high-level abstraction related to deep learning model representation spirv : support for SPIR-V , a dialect for expressing graphics concepts such as shaders omp : support for OpenMP for expressing automatic multithreading related concepts gpu : GPU dialect designed to express platform-independently operations on the GPU async : dialect for expressing asynchronous operations pdl , pdl_interp : MLIR dialect for MLIR transformation, making it possible to use MLIR pass to analyze MLIR pass","title":"Domain-Specific Dialects"},{"location":"mlir/basic/dialect/#platform-dependent-dialects","text":"Among the above dialects, there are also some dialects for platform-specific optimization. They are designed to describe the characteristics of a certain CPU or instruction set in detail and guide the optimization. Their names are relatively intuitive: GPU: amdgpu nvgpu nvvm : NVVM IR for CUDA ARM: arm_neon arm_sve Intel: amx : The Intel Advanced Matrix Extensions x86vector","title":"Platform-dependent Dialects"},{"location":"mlir/basic/dialect.zh/","text":"\u65b9\u8a00 \u65b9\u8a00\u662f MLIR \u4e2d\u81f3\u5173\u91cd\u8981\u7684\u90e8\u5206\u3002\u53ef\u4ee5\u8bf4\uff0c\u6ca1\u6709\u5404\u7c7b\u65b9\u8a00\u7684 MLIR \u5c31\u5982\u540c\u4e00\u95e8\u6ca1\u6709\u6807\u51c6\u5e93\u7684\u8bed\u8a00\u4e00\u6837\uff0c\u5c06\u4e0d\u4f1a\u6709\u4efb\u4f55\u73b0\u5b9e\u7684\u7528\u5904\u3002\u5982\u679c\u5c06 MLIR \u6846\u67b6\u672c\u8eab\u6bd4\u4f5c\u5730\u57fa\u7684\u8bdd\uff0c\u90a3\u4e48\u5728 MLIR \u4e4b\u4e0a\u6784\u5efa\u800c\u51fa\u7684\u5404\u79cd\u65b9\u8a00\u4fbf\u662f\u4e00\u5ea7\u5ea7\u98ce\u683c\u5404\u5f02\u7684\u5927\u697c\u3002\u6570\u636e\u4e0e\u4fe1\u606f\u5728\u5927\u697c\u4e4b\u5185\u4e0e\u4e4b\u95f4\u4e92\u76f8\u6d41\u8f6c\uff0c\u6784\u6210\u4e00\u5ea7\u6709\u673a\u7684\u57ce\u5e02\u3002 \u5c31\u5b66\u4e60\u800c\u8a00\uff0c\u5bf9\u65b9\u8a00\u7684\u5b66\u4e60\u53c8\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\uff1a \u5b66\u4e60\u5982\u4f55\u6784\u5efa\u81ea\u5df1\u7684\u65b9\u8a00 \u5b66\u4e60\u81ea\u5e26\u7684\u65b9\u8a00\u4e2d\u5404\u7c7b\u64cd\u4f5c\u7684\u610f\u4e49 \u524d\u8005\u5c31\u597d\u6bd4\u5b66\u4e60\u9020\u697c\uff0c\u540e\u8005\u5c31\u7c7b\u4f3c\u4e8e\u53c2\u89c2 \"\u6837\u677f\u623f\". \u57fa\u672c\u6982\u5ff5 \u4e00\u4e2a\u65b9\u8a00\u57fa\u672c\u4e0a\u53ef\u4ee5\u5b8c\u5168\u5b9a\u4e49\u5c5e\u4e8e\u5b83\u7684\u4efb\u4f55\u4e1c\u897f\uff0c\u6bd4\u5982\u65b0\u7684\u64cd\u4f5c/\u5c5e\u6027/\u7c7b\u578b\u3002\u65b9\u8a00\u91cc\u7684\u65b0\u64cd\u4f5c\u53ef\u4ee5\u5b9a\u4e49\u81ea\u5df1\u4e13\u5c5e\u7684\u8bed\u6cd5\u683c\u5f0f\u548c\u8f93\u51fa\u683c\u5f0f\u3002\u5728\u4e0d\u540c\u7684\u65b9\u8a00\u7684\u64cd\u4f5c\u4e2d\u89c1\u5230\u6587\u672c\u5f62\u5f0f\u6bd4\u8f83\u72ec\u7279\u7684\u64cd\u4f5c\u662f\u975e\u5e38\u5408\u7406\u4e14\u6b63\u5e38\u7684\u3002 \u6765\u81ea\u4e0d\u540c\u7684\u65b9\u8a00\u7684\u4e8b\u7269\u53ef\u4ee5\u548c\u8c10\u5171\u5b58\u4e8e\u540c\u4e00\u4e2a\u6a21\u5757/\u51fd\u6570\u3002\u540c\u65f6\u65b9\u8a00\u7f16\u5199\u8005\u53ef\u4ee5\u63d0\u4f9b\u5c06\u522b\u7684\u65b9\u8a00\u91cc\u7684\u64cd\u4f5c\u8f6c\u6362\u5230\u81ea\u5df1\u65b9\u8a00\u4e2d\u7684 pass, \u4e5f\u53ef\u4ee5\u7f16\u5199\u5c06\u81ea\u5df1\u65b9\u8a00\u91cc\u7684\u64cd\u4f5c\u8f6c\u6362\u5230\u5176\u5b83\u65b9\u8a00\u53bb\u7684 pass \u3002\u8fd9\u4e9b\u8f6c\u6362\u53ef\u4ee5\u662f\u5b8c\u5168\u7684\uff0c\u5c06 A \u65b9\u8a00\u6240\u6709\u64cd\u4f5c\u90fd\u8f6c\u5230 B \u53bb\uff0c\u53e6\u5916\u4e5f\u53ef\u4ee5\u9010\u6b65\u8f6c\u6362\uff0c\u4f8b\u5982\u53ea\u628a A \u4e2d\u90e8\u5206\u64cd\u4f5c\u8f6c\u5230 B, \u7136\u540e\u5269\u4e0b\u7684\u8f6c\u5230 C. \u8003\u8651\u4e0b\u9762\u7684\u4f8b\u5b50\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // \u4f7f\u7528 func \u65b9\u8a00\u4e2d\u7684 func \u64cd\u4f5c\u6765\u5b9a\u4e49\u51fd\u6570 // \u4f7f\u7528\u4e86\u81ea\u5b9a\u4e49\u8bed\u6cd5, \u4f7f\u5f97\u8be5\u64cd\u4f5c\u7684\u6587\u672c\u5f62\u5f0f\u770b\u8d77\u6765\u8ddf\u666e\u901a\u8bed\u8a00\u4e2d\u7684\u51fd\u6570\u5b9a\u4e49\u7c7b\u4f3c func.func @main() { // \u4f7f\u7528 arith \u65b9\u8a00\u4e2d\u7684 constant \u64cd\u4f5c // \u4f7f\u7528\u4e86\u57fa\u672c\u7684\u8bed\u6cd5 %lb = arith.constant 0 : index %ub = arith.constant 5 : index %step = arith.constant 1 : index %sum_0 = arith.constant 0.0 : f32 %t = arith.constant 5.0 : f32 // \u4f7f\u7528 scf \u65b9\u8a00\u4e2d\u7684 for \u64cd\u4f5c // \u5b83\u6709\u81ea\u5b9a\u4e49\u7684\u8bed\u6cd5, \u53ef\u4ee5\u5199\u6210\u770b\u8d77\u6765\u50cf\u5176\u5b83\u8bed\u8a00\u4e2d\u7684 \"\u5c3e\u968f\u95ed\u5305\" \u4e00\u6837\u7684\u5199\u6cd5 // \u5c06\u4e00\u4e2a \"\u51fd\u6570\" \u4f5c\u4e3a\u81ea\u5df1\u7684\u53c2\u6570 %sum = scf.for %iv = %lb to %ub step %step iter_args(%sum_iter = %sum_0) -> (f32) { %1 = arith.addf %sum_iter , %t : f32 scf.yield %1 : f32 } // \u4f7f\u7528 vector \u65b9\u8a00\u4e2d\u7684 print \u64cd\u4f5c vector.print %sum : f32 return } \u8fd9\u4e2a\u4f8b\u5b50\u7f16\u5199\u5b8c\u540e\uff0c\u4fbf\u53ef\u4ee5\u4f7f\u7528\u5404\u79cd\u8f6c\u6362 pass, \u6216\u9010\u6b65\u6216\u76f4\u63a5\u5730\u5c06\u5404\u79cd\u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\u8f6c\u6362\u4e3a LLVM \u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\uff0c\u968f\u540e\u7ffb\u8bd1\u4e3a LLVM IR, \u5f97\u5230\u53ef\u6267\u884c\u6587\u4ef6\u3002\u53ef\u4ee5\u770b\u5230\uff0c\u5404\u4e2a\u65b9\u8a00\u5185\u90e8\u662f\u975e\u5e38\u81ea\u7531\u7684\u3002\u6240\u4ee5\u8981\u9605\u8bfb MLIR \u4ee3\u7801\u6587\u672c\uff0c\u53ea\u719f\u6089 MLIR \u6838\u5fc3\u6846\u67b6\u662f\u8fdc\u8fdc\u4e0d\u591f\u7684\u3002\u5fc5\u987b\u53c2\u8003\u4f60\u6240\u8981\u4f7f\u7528\u7684\u65b9\u8a00\u7684\u6587\u6863\uff0c\u719f\u6089\u5b83\u4eec\u4e4b\u4e2d\u5404\u4e2a\u64cd\u4f5c\u7684\u610f\u4e49\u4e0e\u8bed\u6cd5\uff0c\u624d\u80fd\u9ad8\u6548\u9605\u8bfb\u3002 \u6240\u6709\u65b9\u8a00\u90fd\u662f\u5e73\u7b49\u7684\uff0c\u4f46\u6709\u4e9b\u65b9\u8a00\u66f4\u52a0\u5e73\u7b49\uff0c\u5b83\u4eec\u662f\u88ab\u81ea\u5e26\u5728 MLIR \u9879\u76ee\u4ed3\u5e93\u91cc\u7684\u65b9\u8a00\u3002\u8fd9\u4e9b\u65b9\u8a00\u88ab\u5e7f\u6cdb\u4f7f\u7528\uff0c\u5728\u5b66\u4e60\u5176\u5b83\u65b9\u8a00\u4e4b\u524d\uff0c\u63a8\u8350\u5148\u9605\u8bfb \u6700\u4e3a\u5e38\u7528\u7684\u4e00\u4e9b\u81ea\u5e26\u65b9\u8a00 \u7684\u6587\u6863\u3002 \u6784\u5efa\u65b0\u7684\u65b9\u8a00 \u6b64\u90e8\u5206\u53ef\u4ee5\u53c2\u8003\u5b98\u65b9\u7684 Toy Tutorial \u3002 \u5b66\u4e60\u81ea\u5e26\u65b9\u8a00 \u76ee\u524d MLIR \u5b98\u65b9\u4ed3\u5e93\u4e2d\u5305\u542b\u4e86\u4e00\u4e9b\u81ea\u5e26\u7684\u65b9\u8a00\u548c\u5b83\u4eec\u4e4b\u95f4\u7684\u8f6c\u6362\u3002\u8fd9\u4e9b\u65b9\u8a00\u53ef\u4ee5\u89c6\u4f5c MLIR \u7684 \"\u6807\u51c6\u5e93\". \u89c6\u6cdb\u7528\u7a0b\u5ea6\u548c\u5173\u6ce8\u70b9\u4e0d\u540c\uff0c\u53c8\u53ef\u4ee5\u5c06\u5b83\u4eec\u5206\u7c7b\u5982\u4e0b\uff1a \u7531\u4e8e MLIR \u7684\u9ad8\u901f\u53d1\u5c55\uff0c\u4e0b\u9762\u7684\u65b9\u8a00\u5217\u8868\u5c06\u4e0d\u4f1a\u4fdd\u8bc1\u662f\u5b8c\u5168\u7684\u3002\u5b8c\u6574\u5217\u8868\u8bf7\u53c2\u8003 \u5b98\u65b9\u6587\u6863 (en) \u3002 \u901a\u7528\u65b9\u8a00 \u4e0b\u9762\u662f\u975e\u5e38\u901a\u7528\u7684\u65b9\u8a00\uff0c\u57fa\u672c\u4e0a\u4efb\u4f55\u5176\u5b83\u81ea\u5e26\u65b9\u8a00\u90fd\u4f1a\u6216\u591a\u6216\u5c11\u5730\u7528\u5230\u4e0a\u9762\u7684\u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\uff0c\u5bf9\u5b83\u4eec\u7684\u5b66\u4e60\u662f\u770b\u61c2\u73b0\u6709\u65b9\u8a00\u7684\u91cd\u8981\u90e8\u5206\uff1a builtin : \u5185\u5efa\u65b9\u8a00, \u5305\u542b\u4e00\u4e9b\u5728\u6240\u6709\u65b9\u8a00\u4e2d\u90fd\u53ef\u80fd\u7528\u5230\u7684\u8bbe\u65bd, \u7406\u8bba\u4e0a\u5e94\u8be5\u4e00\u76f4\u4fdd\u6301\u975e\u5e38\u5c0f. \u5b83\u8fd8\u540c\u65f6\u5305\u542b\u4e86\u5404\u4e2a\u81ea\u5e26\u65b9\u8a00\u7684\u57fa\u672c\u7c7b\u578b\u7684\u7c7b\u578b\u5b9a\u4e49 func : \u51fd\u6570\u65b9\u8a00, \u7528\u4e8e\u8868\u8fbe\u51fd\u6570\u5b9a\u4e49/\u51fd\u6570\u8c03\u7528 arith : \u7b97\u672f\u65b9\u8a00, \u5305\u542b\u5404\u7c7b\u57fa\u672c\u7b97\u672f\u64cd\u4f5c affine : \u4eff\u5c04\u53d8\u6362\u65b9\u8a00, \u662f\u5bf9\u7d22\u5f15\u7a7a\u95f4/\u5730\u5740\u7a7a\u95f4\u6620\u5c04\u7684\u9ad8\u5c42\u63cf\u8ff0 memref : \u5185\u5b58\u533a\u57df\u65b9\u8a00, \u662f\u5bf9\u5185\u5b58\u7684\u9ad8\u5c42\u62bd\u8c61\u4e0e\u62bd\u8c61\u4e4b\u4e0a\u7684\u5404\u7c7b\u64cd\u4f5c \u8fd8\u6709\u4e00\u4e9b\u76f8\u5bf9\u4e0d\u90a3\u4e48\u5e38\u7528\u7684\u4f46\u662f\u4e5f\u662f\u901a\u7528\u7684\u65b9\u8a00\uff1a cf : \u8868\u8fbe\u975e\u7ed3\u6784\u5316\u63a7\u5236\u6d41, \u6bd4\u5982 goto \u4e4b\u7c7b\u7684 scf : \u8868\u8fbe\u7ed3\u6784\u5316\u63a7\u5236\u6d41, \u6bd4\u5982 for/while/if \u4e4b\u7c7b\u7684 math : \u5e38\u7528\u6570\u503c\u8fd0\u7b97\u51fd\u6570 complex : \u5e38\u7528\u590d\u6570\u6570\u503c\u8fd0\u7b97\u51fd\u6570 index : \u5e73\u53f0\u65e0\u5173\u7684\u5bf9\u7d22\u5f15\u7c7b\u578b\u7684\u64cd\u4f5c\uff0c\u6216\u8bb8\u53ef\u4ee5\u6bd4\u4f5c \"\u9ad8\u5c42\u6307\u9488\u7b97\u672f\" LLVM \u65b9\u8a00 \u7136\u540e\u662f\u4e00\u4e2a\u975e\u5e38\u7279\u6b8a\u7684\u65b9\u8a00: llvm , LLVM \u65b9\u8a00. \u5b83\u57fa\u672c\u4e0a\u5c31\u662f\u4e00\u4e2a\u8ddf\u4fdd\u6301\u8ddf LLVM IR \u4e2d\u7684\u6982\u5ff5\u4e00\u5bf9\u4e00\u6620\u5c04\u7684\u65b9\u8a00. \u5b83\u5728\u5927\u90e8\u5206\u65b9\u8a00\u4e0b\u964d\u7684\u8fc7\u7a0b\u4e2d\u5145\u5f53 \"\u6700\u5e95\u5c42\" \u7684\u65b9\u8a00, \u5176\u5b83\u65b9\u8a00\u9010\u6b65\u4e0b\u964d\u5230 LLVM \u65b9\u8a00\u4e4b\u540e, \u518d\u5c06 LLVM \u65b9\u8a00\u7ffb\u8bd1\u4e3a LLVM IR, \u968f\u540e\u4fbf\u62e5\u6709\u4e86 LLVM \u7684\u5404\u7c7b\u4f18\u5316\u4e0e\u7ffb\u8bd1\u5230 LLVM \u6240\u6709\u540e\u7aef\u7684\u80fd\u529b\u3002 \u5982\u679c\u4f60\u6709\u4efb\u4f55\u65b9\u8a00\u4e2d\u64cd\u4f5c\u770b\u4e0d\u61c2\uff0c\u5e76\u4e14\u5b83\u540c\u65f6\u8fd8\u63d0\u4f9b\u4e86\u4e00\u4e2a lowering pass \u7684\u8bdd\uff0c\u4f60\u5c31\u53ef\u4ee5\u901a\u8fc7\u9605\u8bfb lowering pass \u770b\u61c2\u5b83\u5230\u5e95\u662f\u4ec0\u4e48\u610f\u601d\u3002\u6574\u4e2a\u8fc7\u7a0b\u7c7b\u4f3c\u4e8e\u4ece\u4e00\u4e2a C \u8bed\u8a00\u7f16\u8bd1\u5668\u4e2d\u5b66\u4e60 C \u8bed\u8a00\u4e00\u6837\u3002\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\uff0cLLVM \u65b9\u8a00\u5145\u5f53\u7c7b\u4f3c\u6c47\u7f16\u8bed\u8a00\u7684\u89d2\u8272\u3002 \u9886\u57df\u7279\u5b9a\u65b9\u8a00 \u63a5\u4e0b\u6765\u4fbf\u662f\u4e00\u4e9b\u9886\u57df\u7279\u5b9a\u65b9\u8a00\uff0c\u5b83\u4eec\u7684\u51fa\u73b0\u591a\u534a\u662f\u4e3a\u4e86\u6709\u6548\u5730\u5728\u62bd\u8c61\u7684\u9ad8\u5c42\u8868\u8fbe\u4e0e\u67d0\u4e2a\u9886\u57df\u9ad8\u5ea6\u76f8\u5173\u7684\u4fe1\u606f\uff0c\u6240\u4ee5\u5bf9\u7279\u5b9a\u9886\u57df\u7684\u7406\u89e3\u4f1a\u5bf9\u7406\u89e3\u4e0b\u9762\u7684\u81ea\u5e26\u65b9\u8a00\u8d77\u5230\u6781\u5927\u7684\u5e2e\u52a9\u3002\u5b83\u4eec\u6709\uff1a vector : \u5411\u91cf\u5316\u65b9\u8a00, \u65e8\u5728\u5e73\u53f0\u65e0\u5173\u5730\u8868\u8fbe\u5404\u7c7b SIMD \u64cd\u4f5c\u7684\u4fe1\u606f linalg : \u4e0e\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b\u8868\u793a\u76f8\u5173\u7684\u9ad8\u5c42\u62bd\u8c61 spirv : \u5bf9 SPIR-V \u7684\u652f\u6301\uff0c\u7528\u4e8e\u8868\u8fbe\u56fe\u5f62\u7740\u8272\u5668\u7b49\u56fe\u5f62\u5b66\u9886\u57df\u6982\u5ff5\u7684\u65b9\u8a00 omp : \u5bf9 OpenMP \u7684\u652f\u6301\uff0c\u7528\u4e8e\u8868\u8fbe\u81ea\u52a8\u591a\u7ebf\u7a0b\u76f8\u5173\u7684\u6982\u5ff5 gpu : GPU \u65b9\u8a00\uff0c\u65e8\u5728\u5e73\u53f0\u65e0\u5173\u5730\u8868\u8fbe GPU \u4e0a\u7684\u64cd\u4f5c\u7684\u4fe1\u606f async : \u8868\u8fbe\u5f02\u6b65\u64cd\u4f5c\u7684\u65b9\u8a00 pdl , pdl_interp : \u7528\u4e8e\u8868\u8fbe MLIR \u53d8\u6362\u7684 MLIR \u65b9\u8a00\uff0c\u65b9\u4fbf\u4f7f\u7528 MLIR pass \u6765\u5206\u6790 MLIR pass \u5e95\u5c42\u5e73\u53f0\u76f8\u5173\u65b9\u8a00 \u81ea\u5e26\u65b9\u8a00\u4e2d\u8fd8\u6709\u5f88\u591a\u7528\u4e8e\u5e95\u5c42\u76f8\u5173\u4f18\u5316\u7684\u65b9\u8a00\u3002\u5b83\u4eec\u65e8\u5728\u8be6\u7ec6\u63cf\u8ff0\u67d0\u4e2a CPU \u6216\u8005\u6307\u4ee4\u96c6\u7684\u7279\u6027\uff0c\u6307\u5bfc\u5e95\u5c42\u76f8\u5173\u4f18\u5316\u3002\u5b83\u4eec\u7684\u540d\u5b57\u90fd\u6bd4\u8f83\u76f4\u89c2\uff1a GPU: amdgpu nvgpu nvvm : NVVM IR for CUDA ARM: arm_neon arm_sve Intel: amx : The Intel Advanced Matrix Extensions x86vector","title":"mlir-dialect"},{"location":"mlir/basic/dialect.zh/#\u65b9\u8a00","text":"\u65b9\u8a00\u662f MLIR \u4e2d\u81f3\u5173\u91cd\u8981\u7684\u90e8\u5206\u3002\u53ef\u4ee5\u8bf4\uff0c\u6ca1\u6709\u5404\u7c7b\u65b9\u8a00\u7684 MLIR \u5c31\u5982\u540c\u4e00\u95e8\u6ca1\u6709\u6807\u51c6\u5e93\u7684\u8bed\u8a00\u4e00\u6837\uff0c\u5c06\u4e0d\u4f1a\u6709\u4efb\u4f55\u73b0\u5b9e\u7684\u7528\u5904\u3002\u5982\u679c\u5c06 MLIR \u6846\u67b6\u672c\u8eab\u6bd4\u4f5c\u5730\u57fa\u7684\u8bdd\uff0c\u90a3\u4e48\u5728 MLIR \u4e4b\u4e0a\u6784\u5efa\u800c\u51fa\u7684\u5404\u79cd\u65b9\u8a00\u4fbf\u662f\u4e00\u5ea7\u5ea7\u98ce\u683c\u5404\u5f02\u7684\u5927\u697c\u3002\u6570\u636e\u4e0e\u4fe1\u606f\u5728\u5927\u697c\u4e4b\u5185\u4e0e\u4e4b\u95f4\u4e92\u76f8\u6d41\u8f6c\uff0c\u6784\u6210\u4e00\u5ea7\u6709\u673a\u7684\u57ce\u5e02\u3002 \u5c31\u5b66\u4e60\u800c\u8a00\uff0c\u5bf9\u65b9\u8a00\u7684\u5b66\u4e60\u53c8\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\uff1a \u5b66\u4e60\u5982\u4f55\u6784\u5efa\u81ea\u5df1\u7684\u65b9\u8a00 \u5b66\u4e60\u81ea\u5e26\u7684\u65b9\u8a00\u4e2d\u5404\u7c7b\u64cd\u4f5c\u7684\u610f\u4e49 \u524d\u8005\u5c31\u597d\u6bd4\u5b66\u4e60\u9020\u697c\uff0c\u540e\u8005\u5c31\u7c7b\u4f3c\u4e8e\u53c2\u89c2 \"\u6837\u677f\u623f\".","title":"\u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#\u57fa\u672c\u6982\u5ff5","text":"\u4e00\u4e2a\u65b9\u8a00\u57fa\u672c\u4e0a\u53ef\u4ee5\u5b8c\u5168\u5b9a\u4e49\u5c5e\u4e8e\u5b83\u7684\u4efb\u4f55\u4e1c\u897f\uff0c\u6bd4\u5982\u65b0\u7684\u64cd\u4f5c/\u5c5e\u6027/\u7c7b\u578b\u3002\u65b9\u8a00\u91cc\u7684\u65b0\u64cd\u4f5c\u53ef\u4ee5\u5b9a\u4e49\u81ea\u5df1\u4e13\u5c5e\u7684\u8bed\u6cd5\u683c\u5f0f\u548c\u8f93\u51fa\u683c\u5f0f\u3002\u5728\u4e0d\u540c\u7684\u65b9\u8a00\u7684\u64cd\u4f5c\u4e2d\u89c1\u5230\u6587\u672c\u5f62\u5f0f\u6bd4\u8f83\u72ec\u7279\u7684\u64cd\u4f5c\u662f\u975e\u5e38\u5408\u7406\u4e14\u6b63\u5e38\u7684\u3002 \u6765\u81ea\u4e0d\u540c\u7684\u65b9\u8a00\u7684\u4e8b\u7269\u53ef\u4ee5\u548c\u8c10\u5171\u5b58\u4e8e\u540c\u4e00\u4e2a\u6a21\u5757/\u51fd\u6570\u3002\u540c\u65f6\u65b9\u8a00\u7f16\u5199\u8005\u53ef\u4ee5\u63d0\u4f9b\u5c06\u522b\u7684\u65b9\u8a00\u91cc\u7684\u64cd\u4f5c\u8f6c\u6362\u5230\u81ea\u5df1\u65b9\u8a00\u4e2d\u7684 pass, \u4e5f\u53ef\u4ee5\u7f16\u5199\u5c06\u81ea\u5df1\u65b9\u8a00\u91cc\u7684\u64cd\u4f5c\u8f6c\u6362\u5230\u5176\u5b83\u65b9\u8a00\u53bb\u7684 pass \u3002\u8fd9\u4e9b\u8f6c\u6362\u53ef\u4ee5\u662f\u5b8c\u5168\u7684\uff0c\u5c06 A \u65b9\u8a00\u6240\u6709\u64cd\u4f5c\u90fd\u8f6c\u5230 B \u53bb\uff0c\u53e6\u5916\u4e5f\u53ef\u4ee5\u9010\u6b65\u8f6c\u6362\uff0c\u4f8b\u5982\u53ea\u628a A \u4e2d\u90e8\u5206\u64cd\u4f5c\u8f6c\u5230 B, \u7136\u540e\u5269\u4e0b\u7684\u8f6c\u5230 C. \u8003\u8651\u4e0b\u9762\u7684\u4f8b\u5b50\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // \u4f7f\u7528 func \u65b9\u8a00\u4e2d\u7684 func \u64cd\u4f5c\u6765\u5b9a\u4e49\u51fd\u6570 // \u4f7f\u7528\u4e86\u81ea\u5b9a\u4e49\u8bed\u6cd5, \u4f7f\u5f97\u8be5\u64cd\u4f5c\u7684\u6587\u672c\u5f62\u5f0f\u770b\u8d77\u6765\u8ddf\u666e\u901a\u8bed\u8a00\u4e2d\u7684\u51fd\u6570\u5b9a\u4e49\u7c7b\u4f3c func.func @main() { // \u4f7f\u7528 arith \u65b9\u8a00\u4e2d\u7684 constant \u64cd\u4f5c // \u4f7f\u7528\u4e86\u57fa\u672c\u7684\u8bed\u6cd5 %lb = arith.constant 0 : index %ub = arith.constant 5 : index %step = arith.constant 1 : index %sum_0 = arith.constant 0.0 : f32 %t = arith.constant 5.0 : f32 // \u4f7f\u7528 scf \u65b9\u8a00\u4e2d\u7684 for \u64cd\u4f5c // \u5b83\u6709\u81ea\u5b9a\u4e49\u7684\u8bed\u6cd5, \u53ef\u4ee5\u5199\u6210\u770b\u8d77\u6765\u50cf\u5176\u5b83\u8bed\u8a00\u4e2d\u7684 \"\u5c3e\u968f\u95ed\u5305\" \u4e00\u6837\u7684\u5199\u6cd5 // \u5c06\u4e00\u4e2a \"\u51fd\u6570\" \u4f5c\u4e3a\u81ea\u5df1\u7684\u53c2\u6570 %sum = scf.for %iv = %lb to %ub step %step iter_args(%sum_iter = %sum_0) -> (f32) { %1 = arith.addf %sum_iter , %t : f32 scf.yield %1 : f32 } // \u4f7f\u7528 vector \u65b9\u8a00\u4e2d\u7684 print \u64cd\u4f5c vector.print %sum : f32 return } \u8fd9\u4e2a\u4f8b\u5b50\u7f16\u5199\u5b8c\u540e\uff0c\u4fbf\u53ef\u4ee5\u4f7f\u7528\u5404\u79cd\u8f6c\u6362 pass, \u6216\u9010\u6b65\u6216\u76f4\u63a5\u5730\u5c06\u5404\u79cd\u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\u8f6c\u6362\u4e3a LLVM \u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\uff0c\u968f\u540e\u7ffb\u8bd1\u4e3a LLVM IR, \u5f97\u5230\u53ef\u6267\u884c\u6587\u4ef6\u3002\u53ef\u4ee5\u770b\u5230\uff0c\u5404\u4e2a\u65b9\u8a00\u5185\u90e8\u662f\u975e\u5e38\u81ea\u7531\u7684\u3002\u6240\u4ee5\u8981\u9605\u8bfb MLIR \u4ee3\u7801\u6587\u672c\uff0c\u53ea\u719f\u6089 MLIR \u6838\u5fc3\u6846\u67b6\u662f\u8fdc\u8fdc\u4e0d\u591f\u7684\u3002\u5fc5\u987b\u53c2\u8003\u4f60\u6240\u8981\u4f7f\u7528\u7684\u65b9\u8a00\u7684\u6587\u6863\uff0c\u719f\u6089\u5b83\u4eec\u4e4b\u4e2d\u5404\u4e2a\u64cd\u4f5c\u7684\u610f\u4e49\u4e0e\u8bed\u6cd5\uff0c\u624d\u80fd\u9ad8\u6548\u9605\u8bfb\u3002 \u6240\u6709\u65b9\u8a00\u90fd\u662f\u5e73\u7b49\u7684\uff0c\u4f46\u6709\u4e9b\u65b9\u8a00\u66f4\u52a0\u5e73\u7b49\uff0c\u5b83\u4eec\u662f\u88ab\u81ea\u5e26\u5728 MLIR \u9879\u76ee\u4ed3\u5e93\u91cc\u7684\u65b9\u8a00\u3002\u8fd9\u4e9b\u65b9\u8a00\u88ab\u5e7f\u6cdb\u4f7f\u7528\uff0c\u5728\u5b66\u4e60\u5176\u5b83\u65b9\u8a00\u4e4b\u524d\uff0c\u63a8\u8350\u5148\u9605\u8bfb \u6700\u4e3a\u5e38\u7528\u7684\u4e00\u4e9b\u81ea\u5e26\u65b9\u8a00 \u7684\u6587\u6863\u3002","title":"\u57fa\u672c\u6982\u5ff5"},{"location":"mlir/basic/dialect.zh/#\u6784\u5efa\u65b0\u7684\u65b9\u8a00","text":"\u6b64\u90e8\u5206\u53ef\u4ee5\u53c2\u8003\u5b98\u65b9\u7684 Toy Tutorial \u3002","title":"\u6784\u5efa\u65b0\u7684\u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#\u5b66\u4e60\u81ea\u5e26\u65b9\u8a00","text":"\u76ee\u524d MLIR \u5b98\u65b9\u4ed3\u5e93\u4e2d\u5305\u542b\u4e86\u4e00\u4e9b\u81ea\u5e26\u7684\u65b9\u8a00\u548c\u5b83\u4eec\u4e4b\u95f4\u7684\u8f6c\u6362\u3002\u8fd9\u4e9b\u65b9\u8a00\u53ef\u4ee5\u89c6\u4f5c MLIR \u7684 \"\u6807\u51c6\u5e93\". \u89c6\u6cdb\u7528\u7a0b\u5ea6\u548c\u5173\u6ce8\u70b9\u4e0d\u540c\uff0c\u53c8\u53ef\u4ee5\u5c06\u5b83\u4eec\u5206\u7c7b\u5982\u4e0b\uff1a \u7531\u4e8e MLIR \u7684\u9ad8\u901f\u53d1\u5c55\uff0c\u4e0b\u9762\u7684\u65b9\u8a00\u5217\u8868\u5c06\u4e0d\u4f1a\u4fdd\u8bc1\u662f\u5b8c\u5168\u7684\u3002\u5b8c\u6574\u5217\u8868\u8bf7\u53c2\u8003 \u5b98\u65b9\u6587\u6863 (en) \u3002","title":"\u5b66\u4e60\u81ea\u5e26\u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#\u901a\u7528\u65b9\u8a00","text":"\u4e0b\u9762\u662f\u975e\u5e38\u901a\u7528\u7684\u65b9\u8a00\uff0c\u57fa\u672c\u4e0a\u4efb\u4f55\u5176\u5b83\u81ea\u5e26\u65b9\u8a00\u90fd\u4f1a\u6216\u591a\u6216\u5c11\u5730\u7528\u5230\u4e0a\u9762\u7684\u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\uff0c\u5bf9\u5b83\u4eec\u7684\u5b66\u4e60\u662f\u770b\u61c2\u73b0\u6709\u65b9\u8a00\u7684\u91cd\u8981\u90e8\u5206\uff1a builtin : \u5185\u5efa\u65b9\u8a00, \u5305\u542b\u4e00\u4e9b\u5728\u6240\u6709\u65b9\u8a00\u4e2d\u90fd\u53ef\u80fd\u7528\u5230\u7684\u8bbe\u65bd, \u7406\u8bba\u4e0a\u5e94\u8be5\u4e00\u76f4\u4fdd\u6301\u975e\u5e38\u5c0f. \u5b83\u8fd8\u540c\u65f6\u5305\u542b\u4e86\u5404\u4e2a\u81ea\u5e26\u65b9\u8a00\u7684\u57fa\u672c\u7c7b\u578b\u7684\u7c7b\u578b\u5b9a\u4e49 func : \u51fd\u6570\u65b9\u8a00, \u7528\u4e8e\u8868\u8fbe\u51fd\u6570\u5b9a\u4e49/\u51fd\u6570\u8c03\u7528 arith : \u7b97\u672f\u65b9\u8a00, \u5305\u542b\u5404\u7c7b\u57fa\u672c\u7b97\u672f\u64cd\u4f5c affine : \u4eff\u5c04\u53d8\u6362\u65b9\u8a00, \u662f\u5bf9\u7d22\u5f15\u7a7a\u95f4/\u5730\u5740\u7a7a\u95f4\u6620\u5c04\u7684\u9ad8\u5c42\u63cf\u8ff0 memref : \u5185\u5b58\u533a\u57df\u65b9\u8a00, \u662f\u5bf9\u5185\u5b58\u7684\u9ad8\u5c42\u62bd\u8c61\u4e0e\u62bd\u8c61\u4e4b\u4e0a\u7684\u5404\u7c7b\u64cd\u4f5c \u8fd8\u6709\u4e00\u4e9b\u76f8\u5bf9\u4e0d\u90a3\u4e48\u5e38\u7528\u7684\u4f46\u662f\u4e5f\u662f\u901a\u7528\u7684\u65b9\u8a00\uff1a cf : \u8868\u8fbe\u975e\u7ed3\u6784\u5316\u63a7\u5236\u6d41, \u6bd4\u5982 goto \u4e4b\u7c7b\u7684 scf : \u8868\u8fbe\u7ed3\u6784\u5316\u63a7\u5236\u6d41, \u6bd4\u5982 for/while/if \u4e4b\u7c7b\u7684 math : \u5e38\u7528\u6570\u503c\u8fd0\u7b97\u51fd\u6570 complex : \u5e38\u7528\u590d\u6570\u6570\u503c\u8fd0\u7b97\u51fd\u6570 index : \u5e73\u53f0\u65e0\u5173\u7684\u5bf9\u7d22\u5f15\u7c7b\u578b\u7684\u64cd\u4f5c\uff0c\u6216\u8bb8\u53ef\u4ee5\u6bd4\u4f5c \"\u9ad8\u5c42\u6307\u9488\u7b97\u672f\"","title":"\u901a\u7528\u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#llvm-\u65b9\u8a00","text":"\u7136\u540e\u662f\u4e00\u4e2a\u975e\u5e38\u7279\u6b8a\u7684\u65b9\u8a00: llvm , LLVM \u65b9\u8a00. \u5b83\u57fa\u672c\u4e0a\u5c31\u662f\u4e00\u4e2a\u8ddf\u4fdd\u6301\u8ddf LLVM IR \u4e2d\u7684\u6982\u5ff5\u4e00\u5bf9\u4e00\u6620\u5c04\u7684\u65b9\u8a00. \u5b83\u5728\u5927\u90e8\u5206\u65b9\u8a00\u4e0b\u964d\u7684\u8fc7\u7a0b\u4e2d\u5145\u5f53 \"\u6700\u5e95\u5c42\" \u7684\u65b9\u8a00, \u5176\u5b83\u65b9\u8a00\u9010\u6b65\u4e0b\u964d\u5230 LLVM \u65b9\u8a00\u4e4b\u540e, \u518d\u5c06 LLVM \u65b9\u8a00\u7ffb\u8bd1\u4e3a LLVM IR, \u968f\u540e\u4fbf\u62e5\u6709\u4e86 LLVM \u7684\u5404\u7c7b\u4f18\u5316\u4e0e\u7ffb\u8bd1\u5230 LLVM \u6240\u6709\u540e\u7aef\u7684\u80fd\u529b\u3002 \u5982\u679c\u4f60\u6709\u4efb\u4f55\u65b9\u8a00\u4e2d\u64cd\u4f5c\u770b\u4e0d\u61c2\uff0c\u5e76\u4e14\u5b83\u540c\u65f6\u8fd8\u63d0\u4f9b\u4e86\u4e00\u4e2a lowering pass \u7684\u8bdd\uff0c\u4f60\u5c31\u53ef\u4ee5\u901a\u8fc7\u9605\u8bfb lowering pass \u770b\u61c2\u5b83\u5230\u5e95\u662f\u4ec0\u4e48\u610f\u601d\u3002\u6574\u4e2a\u8fc7\u7a0b\u7c7b\u4f3c\u4e8e\u4ece\u4e00\u4e2a C \u8bed\u8a00\u7f16\u8bd1\u5668\u4e2d\u5b66\u4e60 C \u8bed\u8a00\u4e00\u6837\u3002\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\uff0cLLVM \u65b9\u8a00\u5145\u5f53\u7c7b\u4f3c\u6c47\u7f16\u8bed\u8a00\u7684\u89d2\u8272\u3002","title":"LLVM \u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#\u9886\u57df\u7279\u5b9a\u65b9\u8a00","text":"\u63a5\u4e0b\u6765\u4fbf\u662f\u4e00\u4e9b\u9886\u57df\u7279\u5b9a\u65b9\u8a00\uff0c\u5b83\u4eec\u7684\u51fa\u73b0\u591a\u534a\u662f\u4e3a\u4e86\u6709\u6548\u5730\u5728\u62bd\u8c61\u7684\u9ad8\u5c42\u8868\u8fbe\u4e0e\u67d0\u4e2a\u9886\u57df\u9ad8\u5ea6\u76f8\u5173\u7684\u4fe1\u606f\uff0c\u6240\u4ee5\u5bf9\u7279\u5b9a\u9886\u57df\u7684\u7406\u89e3\u4f1a\u5bf9\u7406\u89e3\u4e0b\u9762\u7684\u81ea\u5e26\u65b9\u8a00\u8d77\u5230\u6781\u5927\u7684\u5e2e\u52a9\u3002\u5b83\u4eec\u6709\uff1a vector : \u5411\u91cf\u5316\u65b9\u8a00, \u65e8\u5728\u5e73\u53f0\u65e0\u5173\u5730\u8868\u8fbe\u5404\u7c7b SIMD \u64cd\u4f5c\u7684\u4fe1\u606f linalg : \u4e0e\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b\u8868\u793a\u76f8\u5173\u7684\u9ad8\u5c42\u62bd\u8c61 spirv : \u5bf9 SPIR-V \u7684\u652f\u6301\uff0c\u7528\u4e8e\u8868\u8fbe\u56fe\u5f62\u7740\u8272\u5668\u7b49\u56fe\u5f62\u5b66\u9886\u57df\u6982\u5ff5\u7684\u65b9\u8a00 omp : \u5bf9 OpenMP \u7684\u652f\u6301\uff0c\u7528\u4e8e\u8868\u8fbe\u81ea\u52a8\u591a\u7ebf\u7a0b\u76f8\u5173\u7684\u6982\u5ff5 gpu : GPU \u65b9\u8a00\uff0c\u65e8\u5728\u5e73\u53f0\u65e0\u5173\u5730\u8868\u8fbe GPU \u4e0a\u7684\u64cd\u4f5c\u7684\u4fe1\u606f async : \u8868\u8fbe\u5f02\u6b65\u64cd\u4f5c\u7684\u65b9\u8a00 pdl , pdl_interp : \u7528\u4e8e\u8868\u8fbe MLIR \u53d8\u6362\u7684 MLIR \u65b9\u8a00\uff0c\u65b9\u4fbf\u4f7f\u7528 MLIR pass \u6765\u5206\u6790 MLIR pass","title":"\u9886\u57df\u7279\u5b9a\u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#\u5e95\u5c42\u5e73\u53f0\u76f8\u5173\u65b9\u8a00","text":"\u81ea\u5e26\u65b9\u8a00\u4e2d\u8fd8\u6709\u5f88\u591a\u7528\u4e8e\u5e95\u5c42\u76f8\u5173\u4f18\u5316\u7684\u65b9\u8a00\u3002\u5b83\u4eec\u65e8\u5728\u8be6\u7ec6\u63cf\u8ff0\u67d0\u4e2a CPU \u6216\u8005\u6307\u4ee4\u96c6\u7684\u7279\u6027\uff0c\u6307\u5bfc\u5e95\u5c42\u76f8\u5173\u4f18\u5316\u3002\u5b83\u4eec\u7684\u540d\u5b57\u90fd\u6bd4\u8f83\u76f4\u89c2\uff1a GPU: amdgpu nvgpu nvvm : NVVM IR for CUDA ARM: arm_neon arm_sve Intel: amx : The Intel Advanced Matrix Extensions x86vector","title":"\u5e95\u5c42\u5e73\u53f0\u76f8\u5173\u65b9\u8a00"}]}