# 方言

方言是 MLIR 中至关重要的部分。可以说，没有各类方言的 MLIR 就如同一门没有标准库的语言一样，将不会有任何现实的用处。如果将 MLIR 框架本身比作地基的话，那么在 MLIR 之上构建而出的各种方言便是一座座风格各异的大楼。数据与信息在大楼之内与之间互相流转，构成一座有机的城市。

就学习而言，对方言的学习又可以分为两部分：

- 学习如何构建自己的方言
- 学习自带的方言中各类操作的意义

前者就好比学习造楼，后者就类似于参观 "样板房".

## 基本概念

一个方言基本上可以完全定义属于它的任何东西，比如新的操作/属性/类型。方言里的新操作可以定义自己专属的语法格式和输出格式。在不同的方言的操作中见到文本形式比较独特的操作是非常合理且正常的。

来自不同的方言的事物可以和谐共存于同一个模块/函数。同时方言编写者可以提供将别的方言里的操作转换到自己方言中的 pass, 也可以编写将自己方言里的操作转换到其它方言去的 pass 。这些转换可以是完全的，将 A 方言所有操作都转到 B 去，另外也可以逐步转换，例如只把 A 中部分操作转到 B, 然后剩下的转到 C.

考虑下面的例子：

```mlir
// 使用 func 方言中的 func 操作来定义函数
// 使用了自定义语法, 使得该操作的文本形式看起来跟普通语言中的函数定义类似
func.func @main() {
  // 使用 arith 方言中的 constant 操作
  // 使用了基本的语法
  %lb = arith.constant 0 : index
  %ub = arith.constant 5 : index

  %step = arith.constant 1 : index

  %sum_0 = arith.constant 0.0 : f32
  %t = arith.constant 5.0 : f32

  // 使用 scf 方言中的 for 操作
  // 它有自定义的语法, 可以写成看起来像其它语言中的 "尾随闭包" 一样的写法
  // 将一个 "函数" 作为自己的参数
  %sum = scf.for %iv = %lb to %ub step %step
    iter_args(%sum_iter = %sum_0) -> (f32) {
        %1 = arith.addf %sum_iter , %t : f32
        scf.yield %1 : f32
  }

  // 使用 vector 方言中的 print 操作
  vector.print %sum : f32
  return
}
```

这个例子编写完后，便可以使用各种转换 pass, 或逐步或直接地将各种方言中的操作转换为 LLVM 方言中的操作，随后翻译为 LLVM IR, 得到可执行文件。可以看到，各个方言内部是非常自由的。所以要阅读 MLIR 代码文本，只熟悉 MLIR 核心框架是远远不够的。必须参考你所要使用的方言的文档，熟悉它们之中各个操作的意义与语法，才能高效阅读。

所有方言都是平等的，但有些方言更加平等，它们是被自带在 MLIR 项目仓库里的方言。这些方言被广泛使用，在学习其它方言之前，推荐先阅读[最为常用的一些自带方言](#通用方言)的文档。

## 构建新的方言

此部分可以参考官方的 [Toy Tutorial](https://mlir.llvm.org/docs/Tutorials/Toy/)。

## 学习自带方言

目前 MLIR 官方仓库中包含了一些自带的方言和它们之间的转换。这些方言可以视作 MLIR 的 "标准库". 视泛用程度和关注点不同，又可以将它们分类如下：

> 由于 MLIR 的高速发展，下面的方言列表将不会保证是完全的。完整列表请参考官方文档。

### 通用方言

下面是非常通用的方言，基本上任何其它自带方言都会或多或少地用到上面的方言中的操作，对它们的学习是看懂现有方言的重要部分：

- `builtin`: 内建方言, 包含一些在所有方言中都可能用到的设施, 理论上应该一直保持非常小. 它还同时包含了各个自带方言的基本类型的类型定义
- `func`: 函数方言, 用于表达函数定义/函数调用
- `arith`: 算术方言, 包含各类基本算术操作
- `affine`: 仿射变换方言, 是对索引空间/地址空间映射的高层描述
- `memref`: 内存区域方言, 是对内存的高层抽象与抽象之上的各类操作

还有一些相对不那么常用的但是也是通用的方言：

- `cf`: 表达非结构化控制流, 比如 goto 之类的
- `scf`: 表达结构化控制流, 比如 for/while/if 之类的
- `math`: 常用数值运算函数
- `complex`: 常用复数数值运算函数
- `index`: 平台无关的对索引类型的操作，或许可以比作 "高层指针算术"

### LLVM 方言

然后是一个非常特殊的方言: `llvm`, LLVM 方言. 它基本上就是一个跟保持跟 LLVM IR 中的概念一对一映射的方言. 它在大部分方言下降的过程中充当 "最底层" 的方言, 其它方言逐步下降到 LLVM 方言之后, 再将 LLVM 方言翻译为 LLVM IR, 随后便拥有了 LLVM 的各类优化与翻译到 LLVM 所有后端的能力。

如果你有任何方言中操作看不懂，并且它同时还提供了一个 lowering pass 的话，你就可以通过阅读 lowering pass 看懂它到底是什么意思。整个过程类似于从一个 C 语言编译器中学习 C 语言一样。在这个过程中，LLVM 方言充当类似汇编语言的角色。

### 领域特定方言

接下来便是一些领域特定方言，它们的出现多半是为了有效地在抽象的高层表达与某个领域高度相关的信息，所以对特定领域的理解会对理解下面的自带方言起到极大的帮助。它们有：

- `vector`: 向量化方言, 旨在平台无关地表达各类 SIMD 操作的信息
- `linalg`: 与深度学习模型表示相关的高层抽象
- `spirv`: 对 [SPIR-V](https://registry.khronos.org/SPIR-V/) 的支持，用于表达图形着色器等图形学领域概念的方言
- `omp`: 对 [OpenMP](https://www.openmp.org/) 的支持，用于表达自动多线程相关的概念
- `gpu`: GPU 方言，旨在平台无关地表达 GPU 上的操作的信息
- `async`: 表达异步操作的方言
- `pdl`, `pdl_interp`: 用于表达 MLIR 变换的 MLIR 方言，方便使用 MLIR pass 来分析 MLIR pass

### 底层平台相关方言

自带方言中还有很多用于底层相关优化的方言。它们旨在详细描述某个 CPU 或者指令集的特性，指导底层相关优化。它们的名字都比较直观：

- GPU:
    - `amdgpu`
    - `nvgpu`
    - `nvvm`: NVVM IR for CUDA
- ARM:
    - `arm_neon`
    - `arm_sve`
- Intel:
    - `amx`: The Intel Advanced Matrix Extensions
    - `x86vector`
